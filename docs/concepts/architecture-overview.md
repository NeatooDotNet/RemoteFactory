---
layout: default
title: "Architecture Overview"
description: "Understand how RemoteFactory works and its data flow patterns"
parent: Concepts
nav_order: 1
---

# Architecture Overview

RemoteFactory provides a compile-time generated infrastructure for 3-tier applications. This document explains the architecture, data flow, and key components.

## The Problem RemoteFactory Solves

Traditional 3-tier architectures require significant boilerplate:

**Without RemoteFactory:**
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Client    │────>│    DTOs     │────>│ Controllers │────>│   Service   │
│   (Blazor)  │<────│  (manual)   │<────│  (manual)   │<────│   Layer     │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
                          ▲                    ▲                   ▲
                          │                    │                   │
                     You write           You write            You write
                     these DTOs       these controllers     this mapping
```

This leads to:
- **Code duplication**: DTOs mirror domain models
- **Synchronization bugs**: DTOs and models get out of sync
- **Boilerplate overhead**: Controllers, mappers, factories for each entity
- **Scattered authorization**: Access control spread across layers

**With RemoteFactory:**
```
┌─────────────┐              ┌─────────────┐              ┌─────────────┐
│   Client    │─────────────>│  Generated  │─────────────>│   Domain    │
│   (Blazor)  │<─────────────│   Factory   │<─────────────│   Method    │
└─────────────┘              └─────────────┘              └─────────────┘
                                   ▲
                                   │
                             Source Generator
                             does this for you
```

## High-Level Architecture

```
┌──────────────────────────────────────────────────────────────────────────┐
│                              CLIENT                                       │
│  ┌────────────────┐                                                       │
│  │ Blazor/WPF UI  │                                                       │
│  │                │                                                       │
│  │  Inject        │                                                       │
│  │  IPersonModel- │                                                       │
│  │  Factory       │                                                       │
│  └───────┬────────┘                                                       │
│          │ Create(), Fetch(), Save()                                      │
│          ▼                                                                │
│  ┌────────────────┐                                                       │
│  │ PersonModel    │                                                       │
│  │ Factory        │◄─── Generated by Source Generator                     │
│  │ (Remote Mode)  │                                                       │
│  └───────┬────────┘                                                       │
│          │ Serialize & HTTP POST                                          │
└──────────┼───────────────────────────────────────────────────────────────┘
           │
           │ JSON over HTTP (/api/neatoo)
           ▼
┌──────────────────────────────────────────────────────────────────────────┐
│                              SERVER                                       │
│  ┌────────────────┐                                                       │
│  │ UseNeatoo()    │                                                       │
│  │ Endpoint       │                                                       │
│  └───────┬────────┘                                                       │
│          │ Resolve Delegate                                               │
│          ▼                                                                │
│  ┌────────────────┐                                                       │
│  │ PersonModel    │                                                       │
│  │ Factory        │◄─── Same generated code, Server Mode                  │
│  │ (Server Mode)  │                                                       │
│  └───────┬────────┘                                                       │
│          │ Authorization Check                                            │
│          │ Service Injection                                              │
│          ▼                                                                │
│  ┌────────────────┐     ┌────────────────┐                                │
│  │ PersonModel    │────>│ Database       │                                │
│  │ .Fetch()       │     │ (via EF Core)  │                                │
│  │ .Save()        │<────│                │                                │
│  └────────────────┘     └────────────────┘                                │
└──────────────────────────────────────────────────────────────────────────┘
```

## Key Components

### 1. Domain Model Classes

Your domain models are regular C# classes decorated with RemoteFactory attributes:

```csharp
[Factory]
public partial class PersonModel : IPersonModel
{
    [Create]
    public PersonModel() { }

    [Remote]
    [Fetch]
    public async Task<bool> Fetch([Service] IPersonContext context)
    {
        // This runs on the server
    }
}
```

### 2. Generated Factory Interface

RemoteFactory generates a clean interface for each domain model:

```csharp
public interface IPersonModelFactory
{
    IPersonModel? Create();
    Task<IPersonModel?> Fetch();
    Task<IPersonModel?> Save(IPersonModel target);
    Task<Authorized<IPersonModel>> TrySave(IPersonModel target);
    Authorized CanCreate();
    Authorized CanFetch();
    Authorized CanSave();
}
```

### 3. Generated Factory Implementation

The implementation handles both local and remote execution:

```csharp
internal class PersonModelFactory : FactorySaveBase<IPersonModel>, IPersonModelFactory
{
    private readonly IServiceProvider ServiceProvider;
    private readonly IMakeRemoteDelegateRequest? MakeRemoteDelegateRequest;

    // Delegate properties switch between local and remote execution
    public FetchDelegate FetchProperty { get; }

    // Constructor for Server mode (local execution)
    public PersonModelFactory(IServiceProvider serviceProvider, IFactoryCore<IPersonModel> factoryCore)
    {
        FetchProperty = LocalFetch;  // Execute locally
    }

    // Constructor for Remote mode (HTTP calls)
    public PersonModelFactory(IServiceProvider serviceProvider,
        IMakeRemoteDelegateRequest remoteMethodDelegate,
        IFactoryCore<IPersonModel> factoryCore)
    {
        FetchProperty = RemoteFetch;  // Call server via HTTP
    }
}
```

### 4. Delegate Types

Delegates enable the remote invocation system:

```csharp
// Generated delegate type
public delegate Task<Authorized<IPersonModel>> FetchDelegate();

// Registered in DI for server-side resolution
services.AddScoped<FetchDelegate>(cc =>
{
    var factory = cc.GetRequiredService<PersonModelFactory>();
    return () => factory.LocalFetch();
});
```

### 5. Remote Request Handler

The server endpoint deserializes requests and invokes delegates:

```csharp
app.MapPost("/api/neatoo", (HttpContext context, RemoteRequestDto request) =>
{
    var handler = context.RequestServices.GetRequiredService<HandleRemoteDelegateRequest>();
    return handler(request);
});
```

## Data Flow Patterns

### Create Operation (Local)

Create operations typically execute locally since they don't require server resources:

```
Client                              Server
  │                                   │
  │  factory.Create()                 │
  │         │                         │
  │         ▼                         │
  │  ┌──────────────┐                 │
  │  │ LocalCreate()│                 │
  │  │ new Person() │                 │
  │  └──────────────┘                 │
  │         │                         │
  │  ◄──────┘                         │
  │  PersonModel                      │
```

### Fetch Operation (Remote)

Fetch operations call the server to load data:

```
Client                              Server
  │                                   │
  │  factory.Fetch()                  │
  │         │                         │
  │         ▼                         │
  │  ┌──────────────┐                 │
  │  │ RemoteFetch()│                 │
  │  │ HTTP POST    │────────────────>│
  │  └──────────────┘                 │
  │                                   ▼
  │                            ┌──────────────┐
  │                            │ LocalFetch() │
  │                            │ Authorization│
  │                            │ Resolve Svcs │
  │                            │ Call Method  │
  │                            └──────────────┘
  │                                   │
  │  ◄────────────────────────────────┘
  │  JSON serialized PersonModel      │
```

### Save Operation (Remote)

Save determines Insert/Update/Delete based on `IsNew` and `IsDeleted`:

```
Client                              Server
  │                                   │
  │  factory.Save(person)             │
  │         │                         │
  │         ▼                         │
  │  ┌──────────────┐                 │
  │  │ RemoteSave() │                 │
  │  │ Serialize    │                 │
  │  │ HTTP POST    │────────────────>│
  │  └──────────────┘                 │
  │                                   ▼
  │                            ┌──────────────┐
  │                            │ LocalSave()  │
  │                            │              │
  │                            │ if IsDeleted │
  │                            │   Delete()   │
  │                            │ elif IsNew   │
  │                            │   Insert()   │
  │                            │ else         │
  │                            │   Update()   │
  │                            └──────────────┘
  │                                   │
  │  ◄────────────────────────────────┘
  │  Updated PersonModel              │
```

## Execution Modes

RemoteFactory supports three execution modes configured via the `NeatooFactory` enum:

### Server Mode

Used in ASP.NET Core server applications. Delegates are registered for handling remote calls:

```csharp
builder.Services.AddNeatooAspNetCore(typeof(IPersonModel).Assembly);
```

- Factory methods execute locally
- Services (DbContext, etc.) are resolved from DI
- Delegates are registered for remote invocation

### Remote Mode

Used in client applications (Blazor WASM, WPF). Factory methods call the server via HTTP:

```csharp
builder.Services.AddNeatooRemoteFactory(NeatooFactory.Remote, typeof(IPersonModel).Assembly);
```

- Factory methods serialize calls to HTTP
- Results are deserialized from JSON
- Requires HttpClient configuration

### Logical Mode

Used for testing or single-tier applications. Methods execute locally with serialization:

```csharp
builder.Services.AddNeatooRemoteFactory(NeatooFactory.Logical, typeof(IPersonModel).Assembly);
```

- Factory methods execute locally
- Objects are serialized/deserialized (tests round-trip behavior)
- No HTTP calls made

## Serialization

RemoteFactory uses System.Text.Json with custom configuration:

- **Reference preservation**: Object references are maintained during serialization
- **Interface support**: Interfaces serialize/deserialize correctly
- **Type handling**: Concrete types are resolved from registered interfaces

The `NeatooJsonSerializer` handles:
- Delegate parameter serialization
- Result deserialization
- Reference cycle handling

## Authorization Integration

Authorization is checked at the factory level before method execution:

```csharp
public async Task<Authorized<IPersonModel>> LocalFetch()
{
    // Authorization check happens first
    IPersonModelAuth auth = ServiceProvider.GetRequiredService<IPersonModelAuth>();

    var authorized = auth.CanAccess();
    if (!authorized.HasAccess)
        return new Authorized<IPersonModel>(authorized);

    authorized = auth.CanFetch();
    if (!authorized.HasAccess)
        return new Authorized<IPersonModel>(authorized);

    // Then the actual method executes
    var target = ServiceProvider.GetRequiredService<PersonModel>();
    return new Authorized<IPersonModel>(await DoFactoryMethodCallBoolAsync(...));
}
```

## Service Injection

Parameters marked with `[Service]` are resolved from DI on the server:

```csharp
// Your method signature
[Fetch]
public async Task<bool> Fetch([Service] IPersonContext context)

// Generated code resolves the service
var personContext = ServiceProvider.GetRequiredService<IPersonContext>();
target.Fetch(personContext);
```

This ensures server-only services (database contexts, etc.) are never sent to the client.

## Next Steps

- **[Factory Operations](factory-operations.md)**: Deep dive into Create, Fetch, Insert, Update, Delete
- **[Three-Tier Execution](three-tier-execution.md)**: Detailed mode comparison
- **[Service Injection](service-injection.md)**: Using `[Service]` for dependency injection
- **[How It Works](../source-generation/how-it-works.md)**: Understanding source generation
