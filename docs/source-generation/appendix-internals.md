---
layout: default
title: "Appendix: Internals"
description: "Technical deep dive into RemoteFactory source generation"
parent: Source Generation
nav_order: 4
---

# Appendix: Source Generator Internals

This document provides a technical deep dive into how RemoteFactory's source generators work. It's intended for developers who want to understand the internals, debug issues, or contribute to the project.

## Roslyn Source Generator Basics

RemoteFactory uses Roslyn's `IIncrementalGenerator` interface, which provides:

- **Incremental compilation**: Only regenerate when relevant source changes
- **Caching**: Intermediate results are cached for performance
- **Parallelization**: Generation can run in parallel

### Generator Pipeline

```
Source Code → Predicate → Transform → Output
              (filter)   (analyze)   (generate)
```

## Generator Architecture

### FactoryGenerator

The main generator that creates factory classes:

```csharp
[Generator]
public class FactoryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Find all classes/interfaces with [Factory] attribute
        var factoryClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateForGeneration(node),
                transform: static (ctx, _) => GetFactoryInfo(ctx))
            .Where(static info => info is not null);

        // 2. Generate code for each
        context.RegisterSourceOutput(factoryClasses,
            static (ctx, info) => GenerateFactory(ctx, info));
    }
}
```

### Predicate Phase

The predicate quickly filters syntax nodes:

```csharp
static bool IsCandidateForGeneration(SyntaxNode node)
{
    // Fast syntax-only check
    if (node is not ClassDeclarationSyntax and not InterfaceDeclarationSyntax)
        return false;

    var declaration = (TypeDeclarationSyntax)node;

    // Check for [Factory] attribute
    return declaration.AttributeLists
        .SelectMany(list => list.Attributes)
        .Any(attr => attr.Name.ToString().Contains("Factory"));
}
```

### Transform Phase

The transform extracts semantic information:

```csharp
static FactoryInfo? GetFactoryInfo(GeneratorSyntaxContext context)
{
    var declaration = (TypeDeclarationSyntax)context.Node;
    var symbol = context.SemanticModel.GetDeclaredSymbol(declaration);

    if (symbol is null) return null;

    // Verify it actually has [Factory] attribute
    if (!HasFactoryAttribute(symbol)) return null;

    // Check for [SuppressFactory]
    if (HasSuppressFactoryAttribute(symbol)) return null;

    // Extract all the information needed for generation
    return new FactoryInfo
    {
        Namespace = symbol.ContainingNamespace.ToDisplayString(),
        ClassName = symbol.Name,
        IsInterface = symbol is INamedTypeSymbol { TypeKind: TypeKind.Interface },
        Operations = ExtractOperations(symbol),
        AuthorizationType = ExtractAuthorizationType(symbol),
        // ... more properties
    };
}
```

### Caching and Equatability

For incremental generation to work, the transform result must be equatable:

```csharp
// Using a record ensures proper equality comparison
public sealed record FactoryInfo
{
    public string Namespace { get; init; } = "";
    public string ClassName { get; init; } = "";
    public bool IsInterface { get; init; }
    public EquatableArray<OperationInfo> Operations { get; init; }
    // ...
}

// Custom equatable array for collections
public readonly struct EquatableArray<T> : IEquatable<EquatableArray<T>>
    where T : IEquatable<T>
{
    private readonly T[] _items;

    public bool Equals(EquatableArray<T> other)
    {
        return _items.SequenceEqual(other._items);
    }
}
```

This is crucial: if `FactoryInfo.Equals()` returns true, the generator won't regenerate.

## Output Phase

### Code Generation

The generator uses StringBuilder to build the output:

```csharp
static void GenerateFactory(SourceProductionContext context, FactoryInfo info)
{
    var sb = new StringBuilder();

    // Header comment
    sb.AppendLine("/*");
    sb.AppendLine("    READONLY - DO NOT EDIT!!!!");
    sb.AppendLine("    Generated by Neatoo.RemoteFactory");
    sb.AppendLine($"    Predicate Count: {PredicateCount}");
    sb.AppendLine($"    Transform Count: {TransformCount}");
    sb.AppendLine($"    Generate Count: {++GenerateCount}");
    sb.AppendLine("*/");

    // Namespace and usings
    sb.AppendLine($"namespace {info.Namespace}");
    sb.AppendLine("{");

    // Generate interface
    GenerateFactoryInterface(sb, info);

    // Generate implementation
    GenerateFactoryClass(sb, info);

    sb.AppendLine("}");

    // Add to output
    context.AddSource($"{info.Namespace}.{info.ClassName}Factory.g.cs", sb.ToString());
}
```

### Interface Generation

```csharp
static void GenerateFactoryInterface(StringBuilder sb, FactoryInfo info)
{
    sb.AppendLine($"    public interface I{info.ClassName}Factory");
    sb.AppendLine("    {");

    // Create methods
    foreach (var op in info.Operations.Where(o => o.Type == OperationType.Create))
    {
        var returnType = op.IsAsync ? $"Task<I{info.ClassName}?>" : $"I{info.ClassName}?";
        var parameters = FormatParameters(op.Parameters);
        sb.AppendLine($"        {returnType} {op.MethodName}({parameters});");
    }

    // Fetch methods
    foreach (var op in info.Operations.Where(o => o.Type == OperationType.Fetch))
    {
        var parameters = FormatParameters(op.Parameters);
        sb.AppendLine($"        Task<I{info.ClassName}?> {op.MethodName}({parameters});");
    }

    // Save methods
    if (HasWriteOperations(info))
    {
        sb.AppendLine($"        Task<I{info.ClassName}?> Save(I{info.ClassName} target);");
        sb.AppendLine($"        Task<Authorized<I{info.ClassName}>> TrySave(I{info.ClassName} target);");
    }

    // Can* methods
    if (info.AuthorizationType != null)
    {
        foreach (var canMethod in GetCanMethods(info))
        {
            sb.AppendLine($"        Authorized {canMethod}();");
        }
    }

    sb.AppendLine("    }");
}
```

## MapperGenerator

The mapper generator handles `MapTo`/`MapFrom` partial methods:

```csharp
[Generator]
public class MapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var partialMethods = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsPartialMapperMethod(node),
                transform: static (ctx, _) => GetMapperInfo(ctx))
            .Where(static info => info is not null);

        context.RegisterSourceOutput(partialMethods,
            static (ctx, info) => GenerateMapper(ctx, info));
    }
}
```

### Property Matching

```csharp
static void GenerateMapperBody(StringBuilder sb, MapperInfo info)
{
    var sourceProps = GetProperties(info.SourceType);
    var targetProps = GetProperties(info.TargetType);

    foreach (var sourceProp in sourceProps)
    {
        // Skip if [MapperIgnore]
        if (HasMapperIgnoreAttribute(sourceProp)) continue;

        // Find matching target property
        var targetProp = targetProps.FirstOrDefault(p => p.Name == sourceProp.Name);
        if (targetProp == null) continue;

        // Check if target is writable
        if (!targetProp.SetMethod?.IsAccessible) continue;

        // Generate assignment
        if (IsNullableToNonNullable(sourceProp.Type, targetProp.Type))
        {
            sb.AppendLine($"        {info.TargetParam}.{targetProp.Name} = " +
                $"this.{sourceProp.Name} ?? throw new NullReferenceException(" +
                $"\"{info.ClassName}.{sourceProp.Name}\");");
        }
        else
        {
            sb.AppendLine($"        {info.TargetParam}.{targetProp.Name} = " +
                $"this.{sourceProp.Name};");
        }
    }
}
```

## Performance Considerations

### Avoiding Symbol Usage After Transform

A key performance optimization: don't store `ISymbol` references in the transform result. Symbols are tied to a specific compilation and can't be cached.

```csharp
// Bad: Stores symbol reference
public record FactoryInfo
{
    public INamedTypeSymbol Symbol { get; init; }  // Can't be cached!
}

// Good: Extracts needed data
public record FactoryInfo
{
    public string FullTypeName { get; init; }
    public string Namespace { get; init; }
    public EquatableArray<string> MethodNames { get; init; }
}
```

### Minimal Predicate Work

The predicate runs for every syntax node on every keystroke. Keep it fast:

```csharp
// Good: Fast syntax-only check
static bool Predicate(SyntaxNode node)
{
    return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
}

// Bad: Expensive semantic check in predicate
static bool Predicate(SyntaxNode node, CancellationToken ct)
{
    var symbol = semanticModel.GetDeclaredSymbol(node);  // Too slow!
    return HasFactoryAttribute(symbol);
}
```

## Debugging Source Generators

### Enable Logging

Add diagnostic output to track generation:

```csharp
context.RegisterSourceOutput(factoryClasses, (ctx, info) =>
{
    // Add diagnostic
    ctx.ReportDiagnostic(Diagnostic.Create(
        new DiagnosticDescriptor(
            "NEATOO001",
            "Factory Generated",
            $"Generated factory for {info.ClassName}",
            "Generation",
            DiagnosticSeverity.Info,
            isEnabledByDefault: true),
        Location.None));

    GenerateFactory(ctx, info);
});
```

### Attach Debugger

Add `Debugger.Launch()` to break into the generator:

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    #if DEBUG
    if (!Debugger.IsAttached)
    {
        Debugger.Launch();
    }
    #endif

    // ... rest of initialization
}
```

### View Generated Files

Enable file output in your project:

```xml
<PropertyGroup>
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
    <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)generated</CompilerGeneratedFilesOutputPath>
</PropertyGroup>
```

Generated files appear in: `obj/Debug/net8.0/generated/`

## Diagnostic Header

The generated code includes a diagnostic header:

```csharp
/*
    READONLY - DO NOT EDIT!!!!
    Generated by Neatoo.RemoteFactory
    Predicate Count: 47
    Transform Count: 12
    Generate Count: 3
*/
```

- **Predicate Count**: How many times the predicate ran (high = many syntax nodes)
- **Transform Count**: How many times semantic analysis ran (should be stable)
- **Generate Count**: How many times code was emitted (should equal unique factory count)

If Transform Count keeps increasing, caching isn't working properly.

## Common Issues

### Generator Not Running

Check:
1. Package reference includes analyzer assets
2. Class has `[Factory]` attribute
3. No compilation errors preventing analysis

### Stale Generated Code

Force regeneration:
1. Clean solution
2. Delete `obj` folders
3. Rebuild

### Performance Problems

Signs of issues:
- Slow IntelliSense
- High CPU during typing
- Increasing Transform Count

Solutions:
1. Ensure proper equality on transform result types
2. Minimize work in predicate
3. Don't store symbols in cached data

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        Roslyn Compiler                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                   IIncrementalGenerator                         │
│                                                                 │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────────────┐ │
│  │  Predicate  │───>│  Transform  │───>│  Output             │ │
│  │  (Syntax)   │    │  (Semantic) │    │  (CodeGen)          │ │
│  │             │    │             │    │                     │ │
│  │ Find nodes  │    │ Extract     │    │ Generate C#         │ │
│  │ with        │    │ FactoryInfo │    │ source code         │ │
│  │ [Factory]   │    │ record      │    │                     │ │
│  └─────────────┘    └──────┬──────┘    └─────────────────────┘ │
│                            │                                    │
│                            ▼                                    │
│                     ┌─────────────┐                             │
│                     │   Cache     │                             │
│                     │  (if equal) │                             │
│                     └─────────────┘                             │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│              Generated .g.cs Files                              │
│                                                                 │
│  PersonModelFactory.g.cs                                        │
│  OrderModelFactory.g.cs                                         │
│  PersonModelMapper.g.cs                                         │
└─────────────────────────────────────────────────────────────────┘
```

## Next Steps

- **[How It Works](how-it-works.md)**: High-level overview
- **[Factory Generator](factory-generator.md)**: Factory generation details
- **[Mapper Generator](mapper-generator.md)**: Mapper generation details
