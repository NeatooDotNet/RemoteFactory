# NF0203: Ambiguous save operations

## Description

Multiple Insert, Update, or Delete methods with the same parameter signature and name pattern were found. Only the first matching method will be used in the generated `Save` method.

| Property | Value |
|----------|-------|
| **Diagnostic ID** | NF0203 |
| **Severity** | Warning |
| **Category** | RemoteFactory.Configuration |
| **Default** | Enabled |

## Example

The following code triggers NF0203:

```csharp
[Factory]
public partial class Customer : IFactorySaveMeta
{
    public bool IsNew { get; set; }
    public bool IsDeleted { get; set; }

    // Warning NF0203: Two Insert methods with same signature
    [Insert]
    public void Insert()
    {
        // First insert implementation
    }

    [Insert]
    public void InsertAudit()
    {
        // Second insert implementation - ambiguous!
    }
}
```

## How to Fix

**Option 1: Use different parameter signatures**

If you need multiple insert methods, give them different parameters:

```csharp
[Factory]
public partial class Customer : IFactorySaveMeta
{
    public bool IsNew { get; set; }
    public bool IsDeleted { get; set; }

    [Insert]
    public void Insert()
    {
        // Standard insert
    }

    [Insert]
    public void Insert(bool auditEnabled)
    {
        // Insert with auditing option
    }
}
```

**Option 2: Keep only one method**

If you don't need multiple implementations, remove the duplicate:

```csharp
[Factory]
public partial class Customer : IFactorySaveMeta
{
    public bool IsNew { get; set; }
    public bool IsDeleted { get; set; }

    [Insert]
    public void Insert()
    {
        // Single insert implementation with all logic
    }
}
```

## Why This Matters

The `Save` method generated by RemoteFactory automatically routes to the appropriate operation based on the object's state:
- `IsNew == true` -> calls `Insert`
- `IsNew == false && IsDeleted == false` -> calls `Update`
- `IsDeleted == true` -> calls `Delete`

When multiple methods have the same signature for the same operation, the generator cannot determine which one to use. It will use the first one found, which may not be your intended behavior.

## Save Method Generation

For each unique parameter signature, RemoteFactory generates a `Save` method:

```csharp
// Generated code
public async Task<Customer?> Save(Customer target)
{
    if (target.IsDeleted)
        return LocalDelete(target);
    else if (target.IsNew)
        return LocalInsert(target);
    else
        return LocalUpdate(target);
}
```

Multiple operations with different names but the same signature will share one `Save` method.

## Related Diagnostics

- [NF0202](NF0202.md) - Authorization method has invalid return type
- [NF0204](NF0204.md) - Write operation should not return target type
