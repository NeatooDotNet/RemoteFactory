---
layout: default
title: "Generated Code"
description: "Understanding the structure of generated factory code"
parent: Reference
nav_order: 4
---

# Generated Code Reference

This document provides a complete reference for understanding the code generated by RemoteFactory's source generators.

## Generated File Location

Generated files appear in your project's `obj` folder:

```
MyProject/
├── obj/
│   └── Debug/
│       └── net8.0/
│           └── generated/
│               └── Neatoo.RemoteFactory.FactoryGenerator/
│                   └── Neatoo.RemoteFactory.FactoryGenerator.FactoryGenerator/
│                       ├── MyNamespace.PersonModelFactory.g.cs
│                       └── MyNamespace.OrderModelFactory.g.cs
```

To view in IDE:
- **Visual Studio**: Expand Dependencies > Analyzers > Neatoo.RemoteFactory.FactoryGenerator
- **Rider**: Navigate to the generated folder in Project view
- **VS Code**: Open the file path directly

## Generated File Structure

Each generated file contains:

```csharp
#nullable enable
using Neatoo.RemoteFactory;
using Neatoo.RemoteFactory.Internal;
using Microsoft.Extensions.DependencyInjection;
// ... additional usings from your code

/*
    READONLY - DO NOT EDIT!!!!
    Generated by Neatoo.RemoteFactory
    Predicate Count: 1
    Transform Count: 1
    Generate Count: 1
*/
namespace MyNamespace
{
    public interface IPersonModelFactory { ... }

    internal class PersonModelFactory : FactorySaveBase<IPersonModel>, IPersonModelFactory { ... }
}
```

### Diagnostic Header

The header provides debugging information:

```csharp
/*
    READONLY - DO NOT EDIT!!!!
    Generated by Neatoo.RemoteFactory
    Predicate Count: 1    // Syntax analysis passes
    Transform Count: 1    // Semantic analysis passes
    Generate Count: 1     // Code generation passes
*/
```

If Transform Count keeps increasing, the incremental generator cache isn't working properly.

## Factory Interface

### Complete Interface Example

```csharp
public interface IPersonModelFactory
{
    // Create methods (from [Create] constructors/methods)
    IPersonModel? Create();
    IPersonModel? Create(string firstName, string lastName);

    // Fetch methods (from [Fetch] methods)
    Task<IPersonModel?> Fetch();
    Task<IPersonModel?> Fetch(int id);

    // Save methods (if IFactorySaveMeta implemented)
    Task<IPersonModel?> Save(IPersonModel target);
    Task<Authorized<IPersonModel>> TrySave(IPersonModel target);

    // Can* methods (from [AuthorizeFactory<T>])
    Authorized CanCreate();
    Authorized CanFetch();
    Authorized CanUpdate();
    Authorized CanDelete();
    Authorized CanSave();
}
```

### Interface Generation Rules

| Domain Model | Generated Interface Method |
|--------------|---------------------------|
| `[Create] public PersonModel()` | `IPersonModel? Create()` |
| `[Create] public PersonModel(int x)` | `IPersonModel? Create(int x)` |
| `[Fetch] public Task<bool> Fetch(int id, [Service] IContext ctx)` | `Task<IPersonModel?> Fetch(int id)` |
| `IFactorySaveMeta` implementation | `Save()` and `TrySave()` methods |
| `[AuthorizeFactory<T>]` with `CanX()` | `Authorized CanX()` methods |

## Factory Implementation

### Class Declaration

```csharp
internal class PersonModelFactory :
    FactorySaveBase<IPersonModel>,     // Base class for save operations
    IFactorySave<PersonModel>,          // Allows saving via interface
    IPersonModelFactory                 // The generated interface
{
```

### Fields and Properties

```csharp
private readonly IServiceProvider ServiceProvider;
private readonly IMakeRemoteDelegateRequest? MakeRemoteDelegateRequest;

// Delegate types for remote execution
public delegate Task<Authorized<IPersonModel>> FetchDelegate(int id);
public delegate Task<Authorized<IPersonModel>> SaveDelegate(IPersonModel target);

// Delegate properties for execution routing
public FetchDelegate FetchProperty { get; }
public SaveDelegate SaveProperty { get; }
```

### Constructors

Two constructors control local vs remote execution:

```csharp
// Server mode constructor (local execution)
public PersonModelFactory(
    IServiceProvider serviceProvider,
    IFactoryCore<IPersonModel> factoryCore) : base(factoryCore)
{
    this.ServiceProvider = serviceProvider;
    FetchProperty = LocalFetch;    // Points to local method
    SaveProperty = LocalSave;
}

// Remote mode constructor (HTTP execution)
public PersonModelFactory(
    IServiceProvider serviceProvider,
    IMakeRemoteDelegateRequest remoteMethodDelegate,
    IFactoryCore<IPersonModel> factoryCore) : base(factoryCore)
{
    this.ServiceProvider = serviceProvider;
    this.MakeRemoteDelegateRequest = remoteMethodDelegate;
    FetchProperty = RemoteFetch;   // Points to HTTP method
    SaveProperty = RemoteSave;
}
```

The DI container selects the constructor based on whether `IMakeRemoteDelegateRequest` is registered.

## Method Types

### Create Methods

```csharp
// Public method - calls Local
public virtual IPersonModel? Create()
{
    return (LocalCreate()).Result;  // Unwrap Authorized<T>
}

// Local implementation with authorization
public Authorized<IPersonModel> LocalCreate()
{
    Authorized authorized;

    // Authorization checks
    IPersonModelAuth auth = ServiceProvider.GetRequiredService<IPersonModelAuth>();
    authorized = auth.CanAccess();
    if (!authorized.HasAccess)
    {
        return new Authorized<IPersonModel>(authorized);
    }

    authorized = auth.CanCreate();
    if (!authorized.HasAccess)
    {
        return new Authorized<IPersonModel>(authorized);
    }

    // Execute with lifecycle hooks
    return new Authorized<IPersonModel>(
        DoFactoryMethodCall(FactoryOperation.Create, () => new PersonModel()));
}
```

### Fetch Methods

```csharp
// Public method - routes through delegate
public virtual async Task<IPersonModel?> Fetch(int id)
{
    return (await FetchProperty(id)).Result;
}

// Remote implementation - HTTP call
public virtual async Task<Authorized<IPersonModel>> RemoteFetch(int id)
{
    return (await MakeRemoteDelegateRequest!
        .ForDelegate<Authorized<IPersonModel>>(typeof(FetchDelegate), [id]))!;
}

// Local implementation - service execution
public async Task<Authorized<IPersonModel>> LocalFetch(int id)
{
    Authorized authorized;

    // Authorization
    IPersonModelAuth auth = ServiceProvider.GetRequiredService<IPersonModelAuth>();
    authorized = auth.CanAccess();
    if (!authorized.HasAccess)
    {
        return new Authorized<IPersonModel>(authorized);
    }

    authorized = auth.CanFetch();
    if (!authorized.HasAccess)
    {
        return new Authorized<IPersonModel>(authorized);
    }

    // Resolve target and services
    var target = ServiceProvider.GetRequiredService<PersonModel>();
    var personContext = ServiceProvider.GetRequiredService<IPersonContext>();

    // Execute with lifecycle hooks, returns null if Fetch returns false
    return new Authorized<IPersonModel>(
        await DoFactoryMethodCallBoolAsync(target, FactoryOperation.Fetch,
            () => target.Fetch(id, personContext)));
}
```

### Save Methods

```csharp
// Public method - throws on authorization failure
public virtual async Task<IPersonModel?> Save(IPersonModel target)
{
    var authorized = (await SaveProperty(target));
    if (!authorized.HasAccess)
    {
        throw new NotAuthorizedException(authorized);
    }
    return authorized.Result;
}

// TrySave - returns authorization result
public virtual async Task<Authorized<IPersonModel>> TrySave(IPersonModel target)
{
    return await SaveProperty(target);
}

// Remote Save
public virtual async Task<Authorized<IPersonModel>> RemoteSave(IPersonModel target)
{
    return (await MakeRemoteDelegateRequest!
        .ForDelegate<Authorized<IPersonModel>>(typeof(SaveDelegate), [target]))!;
}

// Local Save - routes based on IsNew/IsDeleted
public virtual async Task<Authorized<IPersonModel>> LocalSave(IPersonModel target)
{
    if (target.IsDeleted)
    {
        if (target.IsNew)
        {
            // New + Deleted = nothing to persist
            return new Authorized<IPersonModel>();
        }
        return await LocalDelete(target);
    }
    else if (target.IsNew)
    {
        return await LocalInsert(target);
    }
    else
    {
        return await LocalUpdate(target);
    }
}
```

### Write Operation Methods

```csharp
// Insert (for [Insert] methods)
public async Task<Authorized<IPersonModel>> LocalInsert(IPersonModel target)
{
    // Authorization checks...

    var cTarget = (PersonModel)target
        ?? throw new Exception("IPersonModel must implement PersonModel");
    var ctx = ServiceProvider.GetRequiredService<IPersonContext>();

    return new Authorized<IPersonModel>(
        await DoFactoryMethodCallAsync(cTarget, FactoryOperation.Insert,
            () => cTarget.Insert(ctx)));
}

// Update (for [Update] methods)
public async Task<Authorized<IPersonModel>> LocalUpdate(IPersonModel target)
{
    // Similar structure...
}

// Delete (for [Delete] methods)
public async Task<Authorized<IPersonModel>> LocalDelete(IPersonModel target)
{
    // Similar structure...
}

// Upsert (for [Insert][Update] combined methods)
public async Task<Authorized<IPersonModel>> LocalUpsert(IPersonModel target)
{
    // Called for Update operation
}

public async Task<Authorized<IPersonModel>> LocalUpsert1(IPersonModel target)
{
    // Called for Insert operation (same method, different FactoryOperation)
}
```

### Can Methods

```csharp
public virtual Authorized CanCreate()
{
    return LocalCanCreate();
}

public Authorized LocalCanCreate()
{
    Authorized authorized;
    IPersonModelAuth auth = ServiceProvider.GetRequiredService<IPersonModelAuth>();

    authorized = auth.CanAccess();
    if (!authorized.HasAccess)
    {
        return authorized;
    }

    authorized = auth.CanCreate();
    if (!authorized.HasAccess)
    {
        return authorized;
    }

    return new Authorized(true);
}

// CanSave checks both Update and Delete
public Authorized LocalCanSave()
{
    Authorized authorized;
    IPersonModelAuth auth = ServiceProvider.GetRequiredService<IPersonModelAuth>();

    authorized = auth.CanAccess();
    if (!authorized.HasAccess) return authorized;

    authorized = auth.CanUpdate();
    if (!authorized.HasAccess) return authorized;

    authorized = auth.CanDelete();
    if (!authorized.HasAccess) return authorized;

    return new Authorized(true);
}
```

## DI Registration

### FactoryServiceRegistrar Method

```csharp
public static void FactoryServiceRegistrar(IServiceCollection services, NeatooFactory mode)
{
    // Factory registrations
    services.AddScoped<PersonModelFactory>();
    services.AddScoped<IPersonModelFactory, PersonModelFactory>();

    // Delegate registrations (for server to handle remote calls)
    services.AddScoped<FetchDelegate>(cc =>
    {
        var factory = cc.GetRequiredService<PersonModelFactory>();
        return (int id) => factory.LocalFetch(id);
    });

    services.AddScoped<SaveDelegate>(cc =>
    {
        var factory = cc.GetRequiredService<PersonModelFactory>();
        return (IPersonModel target) => factory.LocalSave(target);
    });

    // Domain model registrations
    services.AddTransient<PersonModel>();
    services.AddTransient<IPersonModel, PersonModel>();

    // Factory save interface (for IFactorySave<T>)
    services.AddScoped<IFactorySave<PersonModel>, PersonModelFactory>();
}
```

### How Registration is Called

The `AddNeatooRemoteFactory` method discovers and calls all `FactoryServiceRegistrar` methods:

```csharp
// In AddRemoteFactoryServices.cs
public static void AddNeatooRemoteFactory(
    this IServiceCollection services,
    NeatooFactory mode,
    params Assembly[] assemblies)
{
    // Find all FactoryServiceRegistrar methods via reflection
    foreach (var assembly in assemblies)
    {
        foreach (var type in assembly.GetTypes())
        {
            var method = type.GetMethod("FactoryServiceRegistrar",
                BindingFlags.Public | BindingFlags.Static);

            if (method != null)
            {
                method.Invoke(null, [services, mode]);
            }
        }
    }

    // Register core services...
}
```

## Execute Operation Generation

For `[Execute]` methods on interfaces or static classes:

```csharp
// Interface definition
[Factory]
public interface IReportService
{
    [Execute]
    Task<byte[]> GenerateReport(ReportParams parameters);
}

// Generated delegate
public delegate Task<byte[]> GenerateReportDelegate(ReportParams parameters);

// Generated factory interface
public interface IReportServiceFactory
{
    Task<byte[]> GenerateReport(ReportParams parameters);
}

// Generated implementation
internal class ReportServiceFactory : IReportServiceFactory
{
    public GenerateReportDelegate GenerateReportProperty { get; }

    // Constructor routes to local or remote
    public ReportServiceFactory(IServiceProvider sp, IFactoryCore<object> factoryCore)
    {
        GenerateReportProperty = LocalGenerateReport;
    }

    public async Task<byte[]> GenerateReport(ReportParams parameters)
    {
        return await GenerateReportProperty(parameters);
    }

    public async Task<byte[]> LocalGenerateReport(ReportParams parameters)
    {
        var impl = ServiceProvider.GetRequiredService<IReportService>();
        return await impl.GenerateReport(parameters);
    }
}
```

## Mapper Generation

For partial `MapTo`/`MapFrom` methods:

```csharp
// Your partial method
public partial class PersonModel
{
    public partial void MapFrom(PersonEntity entity);
    public partial void MapTo(PersonEntity entity);
}

// Generated implementation
public partial class PersonModel
{
    public partial void MapFrom(PersonEntity entity)
    {
        this.Id = entity.Id;
        this.FirstName = entity.FirstName;
        this.LastName = entity.LastName;
        this.Email = entity.Email;
    }

    public partial void MapTo(PersonEntity entity)
    {
        entity.Id = this.Id;
        entity.FirstName = this.FirstName
            ?? throw new NullReferenceException("PersonModel.FirstName");
        entity.LastName = this.LastName
            ?? throw new NullReferenceException("PersonModel.LastName");
        entity.Email = this.Email;
    }
}
```

## Common Generated Patterns

### Authorization Check Pattern

```csharp
Authorized authorized;
IMyAuth auth = ServiceProvider.GetRequiredService<IMyAuth>();

authorized = auth.CanAccess();
if (!authorized.HasAccess)
{
    return new Authorized<IMyModel>(authorized);
}

// Operation-specific check
authorized = auth.CanOperation();
if (!authorized.HasAccess)
{
    return new Authorized<IMyModel>(authorized);
}
```

### Service Resolution Pattern

```csharp
var target = ServiceProvider.GetRequiredService<PersonModel>();
var ctx = ServiceProvider.GetRequiredService<IPersonContext>();
```

### Lifecycle Hook Pattern

```csharp
// For Create (no existing target)
DoFactoryMethodCall(FactoryOperation.Create, () => new PersonModel())

// For operations on existing target
DoFactoryMethodCallAsync(target, FactoryOperation.Update,
    () => target.Update(ctx))

// For bool-returning operations (Fetch)
DoFactoryMethodCallBoolAsync(target, FactoryOperation.Fetch,
    () => target.Fetch(id, ctx))
```

## Debugging Generated Code

### Enable File Output

Add to your `.csproj`:

```xml
<PropertyGroup>
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
    <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)generated</CompilerGeneratedFilesOutputPath>
</PropertyGroup>
```

### Force Regeneration

1. Clean solution
2. Delete `obj` folders
3. Rebuild

### Check Generator Diagnostics

Generated files include diagnostic counts. If counts keep increasing, check:

1. Equality implementation on extracted data
2. Symbol usage in transform phase
3. Predicate efficiency

## Next Steps

- **[Factory Pattern](../concepts/factory-pattern.md)**: How factories work conceptually
- **[Appendix: Internals](../source-generation/appendix-internals.md)**: Deep dive into generator architecture
- **[Attributes Reference](attributes.md)**: All available attributes
