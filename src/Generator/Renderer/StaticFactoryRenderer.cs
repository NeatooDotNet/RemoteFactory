// src/Generator/Renderer/StaticFactoryRenderer.cs
// Renders factories for static classes with [Execute] or [Event] methods.

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Neatoo.RemoteFactory.FactoryGenerator;
using Neatoo.RemoteFactory.Generator.Model;

namespace Neatoo.RemoteFactory.Generator.Renderer;

/// <summary>
/// Renders factory code for static classes with [Execute] or [Event] methods.
/// </summary>
internal static class StaticFactoryRenderer
{
    /// <summary>
    /// Renders the complete factory source code for a static class.
    /// </summary>
    public static string Render(FactoryGenerationUnit unit)
    {
        var model = unit.StaticFactory!;
        var mode = unit.Mode;

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Using statements
        foreach (var u in unit.Usings)
        {
            sb.AppendLine(u);
        }

        // Add hosting using if there are event methods
        if (model.Events.Count > 0)
        {
            sb.AppendLine("using Microsoft.Extensions.Hosting;");
        }

        sb.AppendLine();
        sb.AppendLine("/*");
        sb.AppendLine("    READONLY - DO NOT EDIT!!!!");
        sb.AppendLine("    Generated by Neatoo.RemoteFactory");
        sb.AppendLine("*/");

        sb.AppendLine($"namespace {unit.Namespace}");
        sb.AppendLine("{");

        // Partial class with delegates and service registrar
        sb.AppendLine($"    {model.SignatureText} {{");
        sb.AppendLine();

        // Delegate declarations
        foreach (var del in model.Delegates)
        {
            RenderDelegate(sb, del);
        }

        // Event delegate declarations
        foreach (var evt in model.Events)
        {
            RenderEventDelegate(sb, evt);
        }

        sb.AppendLine();

        // FactoryServiceRegistrar
        RenderFactoryServiceRegistrar(sb, model, mode);

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void RenderDelegate(StringBuilder sb, ExecuteDelegateModel del)
    {
        // Build parameter declarations (exclude CancellationToken, then add optional one at end)
        var paramDecl = string.Join(", ", del.Parameters.Select(p => $"{p.Type} {p.Name}"));
        if (!string.IsNullOrEmpty(paramDecl))
        {
            paramDecl += ", ";
        }
        paramDecl += "CancellationToken cancellationToken = default";

        var nullableMarker = del.IsNullable ? "Nullable" : "";

        sb.AppendLine($"        public delegate Task<{del.ReturnType}> {del.DelegateName}({paramDecl});");
    }

    private static void RenderEventDelegate(StringBuilder sb, EventMethodModel evt)
    {
        var paramDecl = string.Join(", ", evt.Parameters
            .Where(p => !p.IsCancellationToken)
            .Select(p => $"{p.Type} {p.Name}"));

        sb.AppendLine($"        public delegate Task {evt.DelegateName}({paramDecl});");
    }

    private static void RenderFactoryServiceRegistrar(StringBuilder sb, StaticFactoryModel model, FactoryMode mode)
    {
        sb.AppendLine("        internal static void FactoryServiceRegistrar(IServiceCollection services, NeatooFactory remoteLocal)");
        sb.AppendLine("        {");

        // Remote registrations
        sb.AppendLine("            if(remoteLocal == NeatooFactory.Remote)");
        sb.AppendLine("            {");

        foreach (var del in model.Delegates)
        {
            RenderRemoteDelegateRegistration(sb, del, model.TypeName);
        }

        foreach (var evt in model.Events)
        {
            RenderRemoteEventRegistration(sb, evt, model.TypeName);
        }

        sb.AppendLine("            }");
        sb.AppendLine();

        // Local registrations (only in Full mode)
        sb.AppendLine("            if(remoteLocal == NeatooFactory.Logical || remoteLocal == NeatooFactory.Server)");
        sb.AppendLine("            {");

        if (mode == FactoryMode.Full)
        {
            foreach (var del in model.Delegates)
            {
                RenderLocalDelegateRegistration(sb, del, model.TypeName);
            }

            foreach (var evt in model.Events)
            {
                RenderLocalEventRegistration(sb, evt, model.TypeName);
            }
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    private static void RenderRemoteDelegateRegistration(StringBuilder sb, ExecuteDelegateModel del, string typeName)
    {
        // Build parameter declarations (with optional CancellationToken at end)
        var paramDecl = string.Join(", ", del.Parameters.Select(p => $"{p.Type} {p.Name}"));
        if (!string.IsNullOrEmpty(paramDecl))
        {
            paramDecl += ", ";
        }
        paramDecl += "CancellationToken cancellationToken = default";

        // Parameter identifiers (with cancellationToken at end)
        var paramIdentifiers = string.Join(", ", del.Parameters.Select(p => p.Name));
        if (!string.IsNullOrEmpty(paramIdentifiers))
        {
            paramIdentifiers += ", ";
        }
        paramIdentifiers += "cancellationToken";

        // Serialized parameters (exclude CancellationToken)
        var serializedParams = string.Join(", ", del.Parameters.Select(p => p.Name));

        var nullableText = del.IsNullable ? "Nullable" : "";

        sb.AppendLine($"                services.AddTransient<{typeName}.{del.DelegateName}>(cc =>");
        sb.AppendLine("                {");
        sb.AppendLine($"                    return ({paramIdentifiers}) => cc.GetRequiredService<IMakeRemoteDelegateRequest>().ForDelegate{nullableText}<{del.ReturnType}>(typeof({typeName}.{del.DelegateName}), [{serializedParams}], cancellationToken);");
        sb.AppendLine("                });");
    }

    private static void RenderLocalDelegateRegistration(StringBuilder sb, ExecuteDelegateModel del, string typeName)
    {
        // Build parameter declarations (with optional CancellationToken at end)
        var paramDecl = string.Join(", ", del.Parameters.Select(p => $"{p.Type} {p.Name}"));
        if (!string.IsNullOrEmpty(paramDecl))
        {
            paramDecl += ", ";
        }
        paramDecl += "CancellationToken cancellationToken = default";

        // Service assignments
        var serviceAssignments = string.Join("\n                    ",
            del.ServiceParameters.Select(p => $"var {p.Name} = cc.GetRequiredService<{p.Type}>();"));

        // All parameter identifiers for the domain method call (including services and CancellationToken if domain method has it)
        var allParamIdentifiers = BuildDomainMethodInvocationParams(del);

        sb.AppendLine($"                services.AddTransient<{typeName}.{del.DelegateName}>(cc =>");
        sb.AppendLine("                {");
        sb.AppendLine($"                    return ({paramDecl}) => {{");

        if (!string.IsNullOrEmpty(serviceAssignments))
        {
            sb.AppendLine($"                    {serviceAssignments}");
        }

        sb.AppendLine($"                    return {typeName}.{del.Name}({allParamIdentifiers});");
        sb.AppendLine("                    };");
        sb.AppendLine("                });");
    }

    private static string BuildDomainMethodInvocationParams(ExecuteDelegateModel del)
    {
        // Build the full parameter list including services
        var allParams = new List<string>();

        // Add data parameters (already in order)
        allParams.AddRange(del.Parameters.Select(p => p.Name));

        // Add service parameters
        allParams.AddRange(del.ServiceParameters.Select(p => p.Name));

        // Only add cancellationToken if the domain method actually has it
        if (del.HasCancellationToken)
        {
            allParams.Add("cancellationToken");
        }

        return string.Join(", ", allParams);
    }

    private static string BuildEventMethodInvocationParams(EventMethodModel evt)
    {
        // Build the full parameter list including services
        var allParams = new List<string>();

        // Add data parameters (exclude CancellationToken - it's handled separately as 'ct')
        allParams.AddRange(evt.Parameters
            .Where(p => !p.IsCancellationToken)
            .Select(p => p.Name));

        // Add service parameters (resolved from DI)
        allParams.AddRange(evt.ServiceParameters.Select(p => p.Name));

        // Add ct if domain method has CancellationToken
        if (evt.Parameters.Any(p => p.IsCancellationToken))
        {
            allParams.Add("ct");
        }

        return string.Join(", ", allParams);
    }

    private static void RenderRemoteEventRegistration(StringBuilder sb, EventMethodModel evt, string typeName)
    {
        var paramDecl = string.Join(", ", evt.Parameters
            .Where(p => !p.IsCancellationToken)
            .Select(p => $"{p.Type} {p.Name}"));

        var serializedParams = string.Join(", ", evt.Parameters
            .Where(p => !p.IsService && !p.IsCancellationToken)
            .Select(p => p.Name));

        sb.AppendLine($"                services.AddTransient<{typeName}.{evt.DelegateName}>(cc =>");
        sb.AppendLine("                {");
        sb.AppendLine($"                    return ({paramDecl}) => cc.GetRequiredService<IMakeRemoteDelegateRequest>().ForDelegateEvent(typeof({typeName}.{evt.DelegateName}), [{serializedParams}]);");
        sb.AppendLine("                });");
    }

    private static void RenderLocalEventRegistration(StringBuilder sb, EventMethodModel evt, string typeName)
    {
        var paramDecl = string.Join(", ", evt.Parameters
            .Where(p => !p.IsCancellationToken)
            .Select(p => $"{p.Type} {p.Name}"));

        var allParamIdentifiers = BuildEventMethodInvocationParams(evt);

        var serviceAssignments = string.Join("\n                            ",
            evt.ServiceParameters.Select(p => $"var {p.Name} = scope.ServiceProvider.GetRequiredService<{p.Type}>();"));

        // For static classes, call directly on the type name
        var methodInvocation = evt.IsAsync
            ? $"await {typeName}.{evt.Name}({allParamIdentifiers});"
            : $"{typeName}.{evt.Name}({allParamIdentifiers});";

        sb.AppendLine($"                services.AddScoped<{typeName}.{evt.DelegateName}>(sp =>");
        sb.AppendLine("                {");
        sb.AppendLine("                    var scopeFactory = sp.GetRequiredService<IServiceScopeFactory>();");
        sb.AppendLine("                    var tracker = sp.GetRequiredService<IEventTracker>();");
        sb.AppendLine("                    var lifetime = sp.GetRequiredService<IHostApplicationLifetime>();");
        // Capture correlation context from parent scope
        sb.AppendLine("                    var parentCorrelation = sp.GetService<ICorrelationContext>();");
        sb.AppendLine($"                    return ({paramDecl}) =>");
        sb.AppendLine("                    {");
        // Capture correlation ID before Task.Run (outside the lambda closure)
        sb.AppendLine("                        var capturedCorrelationId = parentCorrelation?.CorrelationId;");
        sb.AppendLine("                        var task = Task.Run(async () =>");
        sb.AppendLine("                        {");
        sb.AppendLine("                            using var scope = scopeFactory.CreateScope();");
        // Set correlation ID in the new scope BEFORE resolving any services
        sb.AppendLine("                            var eventCorrelation = scope.ServiceProvider.GetService<ICorrelationContext>();");
        sb.AppendLine("                            if (eventCorrelation != null && capturedCorrelationId != null)");
        sb.AppendLine("                            {");
        sb.AppendLine("                                eventCorrelation.CorrelationId = capturedCorrelationId;");
        sb.AppendLine("                            }");
        sb.AppendLine("                            var ct = lifetime.ApplicationStopping;");

        if (!string.IsNullOrEmpty(serviceAssignments))
        {
            sb.AppendLine($"                            {serviceAssignments}");
        }

        sb.AppendLine($"                            {methodInvocation}");
        sb.AppendLine("                        });");
        sb.AppendLine("                        tracker.Track(task);");
        sb.AppendLine("                        return task;");
        sb.AppendLine("                    };");
        sb.AppendLine("                });");
    }
}
