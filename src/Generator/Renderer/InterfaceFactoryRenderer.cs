// src/Generator/Renderer/InterfaceFactoryRenderer.cs
// Renders factories for interfaces with the [Factory] attribute.

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Neatoo.RemoteFactory.FactoryGenerator;
using Neatoo.RemoteFactory.Generator.Model;

namespace Neatoo.RemoteFactory.Generator.Renderer;

/// <summary>
/// Renders factory code for interfaces with the [Factory] attribute.
/// The generated factory wraps the interface methods and enables remote calls.
/// </summary>
internal static class InterfaceFactoryRenderer
{
    /// <summary>
    /// Renders the complete factory source code for an interface.
    /// </summary>
    public static string Render(FactoryGenerationUnit unit)
    {
        var model = unit.InterfaceFactory!;
        var mode = unit.Mode;

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Using statements
        foreach (var u in unit.Usings)
        {
            sb.AppendLine(u);
        }

        sb.AppendLine();
        sb.AppendLine("/*");
        sb.AppendLine("    READONLY - DO NOT EDIT!!!!");
        sb.AppendLine("    Generated by Neatoo.RemoteFactory");
        sb.AppendLine("*/");

        sb.AppendLine($"namespace {unit.Namespace}");
        sb.AppendLine("{");

        // Factory interface (extends the service interface)
        RenderFactoryInterface(sb, model);

        // Factory implementation class
        RenderFactoryClass(sb, model, mode);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void RenderFactoryInterface(StringBuilder sb, InterfaceFactoryModel model)
    {
        sb.AppendLine($"    public interface {model.ServiceTypeName}Factory : {model.ServiceTypeName}");
        sb.AppendLine("    {");

        // Interface methods for CanXxx methods only (the base interface already has the regular methods)
        foreach (var method in model.Methods.Where(m => m.Name.StartsWith("Can")))
        {
            var returnType = GetReturnType(method);
            var parameters = GetParameterDeclarations(method.Parameters);

            sb.AppendLine($"        {returnType} {method.Name}({parameters});");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void RenderFactoryClass(StringBuilder sb, InterfaceFactoryModel model, FactoryMode mode)
    {
        sb.AppendLine($"    internal class {model.ImplementationTypeName}Factory : {model.ServiceTypeName}Factory");
        sb.AppendLine("    {");

        // Fields
        sb.AppendLine("        private readonly IServiceProvider ServiceProvider;");

        if (mode == FactoryMode.RemoteOnly)
        {
            sb.AppendLine("        private readonly IMakeRemoteDelegateRequest MakeRemoteDelegateRequest;");
        }
        else
        {
            sb.AppendLine("        private readonly IMakeRemoteDelegateRequest? MakeRemoteDelegateRequest;");
        }

        sb.AppendLine();

        // Delegates
        sb.AppendLine("        // Delegates");
        foreach (var method in model.Methods)
        {
            RenderDelegate(sb, method);
        }
        sb.AppendLine();

        // Delegate properties
        sb.AppendLine("        // Delegate Properties to provide Local or Remote fork in execution");
        foreach (var method in model.Methods)
        {
            RenderDelegateProperty(sb, method);
        }
        sb.AppendLine();

        // Constructors
        RenderConstructors(sb, model, mode);

        // Methods
        foreach (var method in model.Methods)
        {
            RenderMethod(sb, method, model, mode);
        }

        // FactoryServiceRegistrar
        RenderFactoryServiceRegistrar(sb, model, mode);

        sb.AppendLine("    }");
    }

    #region Delegate Rendering

    private static void RenderDelegate(StringBuilder sb, InterfaceMethodModel method)
    {
        var returnType = GetReturnType(method);
        var parameters = GetParameterDeclarations(method.Parameters);

        sb.AppendLine($"        public delegate {returnType} {method.UniqueName}Delegate({parameters});");
    }

    private static void RenderDelegateProperty(StringBuilder sb, InterfaceMethodModel method)
    {
        sb.AppendLine($"        public {method.UniqueName}Delegate {method.UniqueName}Property {{ get; }}");
    }

    #endregion

    #region Constructor Rendering

    private static void RenderConstructors(StringBuilder sb, InterfaceFactoryModel model, FactoryMode mode)
    {
        if (mode == FactoryMode.RemoteOnly)
        {
            // RemoteOnly mode: Only generate remote constructor
            sb.AppendLine($"        public {model.ImplementationTypeName}Factory(IServiceProvider serviceProvider, IMakeRemoteDelegateRequest remoteMethodDelegate)");
            sb.AppendLine("        {");
            sb.AppendLine("            this.ServiceProvider = serviceProvider;");
            sb.AppendLine("            this.MakeRemoteDelegateRequest = remoteMethodDelegate;");

            // Remote property assignments
            foreach (var method in model.Methods)
            {
                sb.AppendLine($"            {method.UniqueName}Property = Remote{method.UniqueName};");
            }

            sb.AppendLine("        }");
        }
        else
        {
            // Full mode: Generate both constructors
            // Local constructor
            sb.AppendLine($"        public {model.ImplementationTypeName}Factory(IServiceProvider serviceProvider)");
            sb.AppendLine("        {");
            sb.AppendLine("            this.ServiceProvider = serviceProvider;");

            // Local property assignments
            foreach (var method in model.Methods)
            {
                sb.AppendLine($"            {method.UniqueName}Property = Local{method.UniqueName};");
            }

            sb.AppendLine("        }");
            sb.AppendLine();

            // Remote constructor
            sb.AppendLine($"        public {model.ImplementationTypeName}Factory(IServiceProvider serviceProvider, IMakeRemoteDelegateRequest remoteMethodDelegate)");
            sb.AppendLine("        {");
            sb.AppendLine("            this.ServiceProvider = serviceProvider;");
            sb.AppendLine("            this.MakeRemoteDelegateRequest = remoteMethodDelegate;");

            // Remote property assignments
            foreach (var method in model.Methods)
            {
                sb.AppendLine($"            {method.UniqueName}Property = Remote{method.UniqueName};");
            }

            sb.AppendLine("        }");
        }

        sb.AppendLine();
    }

    #endregion

    #region Method Rendering

    private static void RenderMethod(StringBuilder sb, InterfaceMethodModel method, InterfaceFactoryModel model, FactoryMode mode)
    {
        // Public method (interface implementation)
        RenderPublicMethod(sb, method);

        // Remote method
        RenderRemoteMethod(sb, method);

        // Local method (only in Full mode)
        if (mode == FactoryMode.Full)
        {
            RenderLocalMethod(sb, method, model);
        }
    }

    private static void RenderPublicMethod(StringBuilder sb, InterfaceMethodModel method)
    {
        var returnType = GetReturnType(method);
        var parameters = GetParameterDeclarations(method.Parameters, includeServices: false);
        var paramIdentifiers = GetParameterIdentifiers(method.Parameters, includeServices: false);

        sb.AppendLine($"        public virtual {returnType} {method.Name}({parameters})");
        sb.AppendLine("        {");
        sb.AppendLine($"            return {method.UniqueName}Property({paramIdentifiers});");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void RenderRemoteMethod(StringBuilder sb, InterfaceMethodModel method)
    {
        var returnType = GetReturnType(method);
        var returnTypeWithoutTask = GetReturnTypeWithoutTask(method);
        var parameters = GetParameterDeclarations(method.Parameters);
        var nullableText = returnTypeWithoutTask.EndsWith("?") ? "Nullable" : "";

        // Exclude CancellationToken from serialized parameters
        var serializedParams = string.Join(", ", method.Parameters
            .Where(p => !p.IsService && !p.IsCancellationToken)
            .Select(p => p.Name));

        // Get the CancellationToken parameter name, or "default"
        var ctParam = method.Parameters.FirstOrDefault(p => p.IsCancellationToken);
        var ctParamName = ctParam?.Name ?? "default";

        sb.AppendLine($"        public virtual async {returnType} Remote{method.UniqueName}({parameters})");
        sb.AppendLine("        {");
        sb.AppendLine($"            return (await MakeRemoteDelegateRequest!.ForDelegate{nullableText}<{returnTypeWithoutTask}>(typeof({method.UniqueName}Delegate), [{serializedParams}], {ctParamName}))!;");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void RenderLocalMethod(StringBuilder sb, InterfaceMethodModel method, InterfaceFactoryModel model)
    {
        var asyncKeyword = method.IsAsync ? "async" : "";
        var returnType = GetReturnType(method);
        var parameters = GetParameterDeclarations(method.Parameters);
        var paramIdentifiers = GetParameterIdentifiers(method.Parameters, includeServices: false);

        sb.AppendLine($"        public {asyncKeyword} {returnType} Local{method.UniqueName}({parameters})");
        sb.AppendLine("        {");

        // Authorization checks (interface methods use AspForbid = true)
        RenderAuthorizationChecks(sb, method);

        // Get the target service
        sb.AppendLine($"            var target = ServiceProvider.GetRequiredService<{model.ImplementationTypeName}>();");

        // Service assignments
        RenderServiceAssignments(sb, method.Parameters);

        // Method call
        var methodCall = BuildMethodCall(method, paramIdentifiers);
        sb.AppendLine($"            return {methodCall};");

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string BuildMethodCall(InterfaceMethodModel method, string paramIdentifiers)
    {
        var methodCall = $"target.{method.Name}({paramIdentifiers})";

        if (method.IsAsync && method.IsTask)
        {
            methodCall = $"await {methodCall}";
        }

        if (!method.IsTask && method.IsRemote && !method.IsAsync)
        {
            methodCall = $"Task.FromResult({methodCall})";
        }

        return methodCall;
    }

    #endregion

    #region Authorization Rendering

    private static void RenderAuthorizationChecks(StringBuilder sb, InterfaceMethodModel method)
    {
        if (!method.HasAuth || method.Authorization == null)
        {
            return;
        }

        sb.AppendLine("            Authorized authorized;");

        // Group auth methods by class
        var authMethodsByClass = method.Authorization.AuthMethods.GroupBy(m => m.ClassName);
        foreach (var authClass in authMethodsByClass)
        {
            var className = authClass.Key;
            var varName = className.ToLower();

            sb.AppendLine($"            {className} {varName} = ServiceProvider.GetRequiredService<{className}>();");

            foreach (var authMethod in authClass)
            {
                RenderAuthMethodCall(sb, method, authMethod, varName);
            }
        }

        // ASP.NET Authorize checks (interface methods use AspForbid = true)
        if (method.Authorization.AspAuthorize.Count > 0)
        {
            sb.AppendLine("            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();");

            var aspAuthDataList = method.Authorization.AspAuthorize.Select(asp =>
            {
                var ctorArgs = string.Join(", ", asp.ConstructorArgs);
                var namedArgs = string.Join(", ", asp.NamedArgs);
                var result = $"new AspAuthorizeData({ctorArgs})";
                if (!string.IsNullOrEmpty(namedArgs))
                {
                    result += $"{{ {namedArgs} }}";
                }
                return result;
            });

            var aspAuthDataText = string.Join(", ", aspAuthDataList);
            // Interface methods use AspForbid = true
            sb.AppendLine($"            authorized = await aspAuthorized.Authorize([ {aspAuthDataText} ], true);");
        }
    }

    private static void RenderAuthMethodCall(StringBuilder sb, InterfaceMethodModel factoryMethod, AuthMethodCall authMethod, string varName)
    {
        // Build parameter mapping from factory method params to auth method params
        var authParams = new List<string>();
        var factoryParams = factoryMethod.Parameters.Where(p => !p.IsTarget).ToList();

        foreach (var authParam in authMethod.Parameters)
        {
            var matchingFactoryParam = factoryParams.FirstOrDefault(p => p.Type == authParam.Type);
            if (matchingFactoryParam != null)
            {
                authParams.Add(matchingFactoryParam.Name);
                factoryParams.Remove(matchingFactoryParam);
            }
            else
            {
                authParams.Add($"/* Missing {authParam.Type} {authParam.Name} */");
            }
        }

        var paramText = string.Join(", ", authParams);
        var callText = $"{varName}.{authMethod.MethodName}({paramText})";

        if (authMethod.IsTask)
        {
            callText = $"await {callText}";
        }

        sb.AppendLine($"            authorized = {callText};");
        sb.AppendLine("            if (!authorized.HasAccess)");
        sb.AppendLine("            {");

        // Interface methods throw NotAuthorizedException (AspForbid = true)
        sb.AppendLine("                throw new NotAuthorizedException(authorized);");

        sb.AppendLine("            }");
    }

    #endregion

    #region Service Registration Rendering

    private static void RenderFactoryServiceRegistrar(StringBuilder sb, InterfaceFactoryModel model, FactoryMode mode)
    {
        sb.AppendLine("        public static void FactoryServiceRegistrar(IServiceCollection services, NeatooFactory remoteLocal)");
        sb.AppendLine("        {");

        // Client-side registration (remote mode)
        sb.AppendLine("            // On the client the Factory is registered");
        sb.AppendLine("            // All method calls lead to a remote call");
        sb.AppendLine("            if(remoteLocal == NeatooFactory.Remote)");
        sb.AppendLine("            {");
        sb.AppendLine($"                services.AddScoped<{model.ServiceTypeName}, {model.ImplementationTypeName}Factory>();");
        sb.AppendLine($"                services.AddScoped<{model.ServiceTypeName}Factory, {model.ImplementationTypeName}Factory>();");
        sb.AppendLine("            }");
        sb.AppendLine();

        // Server-side registration
        sb.AppendLine($"            // On the server the Delegates are registered");
        sb.AppendLine($"            // {model.ImplementationTypeName}Factory is not used");
        sb.AppendLine($"            // {model.ServiceTypeName} must be registered to actual implementation");
        sb.AppendLine("            if(remoteLocal == NeatooFactory.Server)");
        sb.AppendLine("            {");
        sb.AppendLine($"                services.AddScoped<{model.ServiceTypeName}Factory, {model.ImplementationTypeName}Factory>();");
        sb.AppendLine($"                services.AddScoped<{model.ImplementationTypeName}Factory>();");

        // Delegate registrations (only in Full mode, server side)
        if (mode == FactoryMode.Full)
        {
            foreach (var method in model.Methods)
            {
                var parameters = GetParameterDeclarations(method.Parameters);
                var paramIdentifiers = GetParameterIdentifiers(method.Parameters);

                sb.AppendLine($"                services.AddScoped<{method.UniqueName}Delegate>(cc => {{");
                sb.AppendLine($"                    var factory = cc.GetRequiredService<{model.ImplementationTypeName}Factory>();");
                sb.AppendLine($"                    return ({parameters}) => factory.{method.Name}({paramIdentifiers});");
                sb.AppendLine("                });");
            }
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    #endregion

    #region Service Assignment Rendering

    private static void RenderServiceAssignments(StringBuilder sb, IReadOnlyList<ParameterModel> parameters)
    {
        foreach (var param in parameters.Where(p => p.IsService))
        {
            sb.AppendLine($"            var {param.Name} = ServiceProvider.GetRequiredService<{param.Type}>();");
        }
    }

    #endregion

    #region Helper Methods

    private static string GetReturnType(InterfaceMethodModel method)
    {
        var returnType = method.ReturnType;

        // Interface methods don't use Authorized<T> wrapper (they throw exceptions instead)
        if (method.IsNullable && !returnType.EndsWith("?"))
        {
            returnType = $"{returnType}?";
        }

        if (method.IsTask && !returnType.StartsWith("Task"))
        {
            returnType = $"Task<{returnType}>";
        }

        return returnType;
    }

    private static string GetReturnTypeWithoutTask(InterfaceMethodModel method)
    {
        var returnType = method.ReturnType;

        if (method.IsNullable && !returnType.EndsWith("?"))
        {
            returnType = $"{returnType}?";
        }

        return returnType;
    }

    private static string GetParameterDeclarations(IReadOnlyList<ParameterModel> parameters, bool includeServices = true)
    {
        return string.Join(", ", parameters
            .Where(p => includeServices || !p.IsService)
            .Select(p => $"{p.Type} {p.Name}"));
    }

    private static string GetParameterIdentifiers(IReadOnlyList<ParameterModel> parameters, bool includeServices = true)
    {
        return string.Join(", ", parameters
            .Where(p => includeServices || !p.IsService)
            .Select(p => p.Name));
    }

    #endregion
}
