// src/Generator/Renderer/OrdinalRenderer.cs
// Renders ordinal serialization support code for entities.

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Neatoo.RemoteFactory.Generator.Model;

namespace Neatoo.RemoteFactory.Generator.Renderer;

/// <summary>
/// Renders ordinal serialization support code for entities.
/// This enables compact JSON serialization using arrays instead of objects with property names.
/// </summary>
internal static class OrdinalRenderer
{
    /// <summary>
    /// Renders the ordinal serialization code for a type.
    /// </summary>
    public static string Render(OrdinalSerializationModel model)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Using statements
        foreach (var u in model.Usings)
        {
            sb.AppendLine(u);
        }

        sb.AppendLine();
        sb.AppendLine("/*");
        sb.AppendLine("    READONLY - DO NOT EDIT!!!!");
        sb.AppendLine("    Generated by Neatoo.RemoteFactory - Ordinal Serialization Support");
        sb.AppendLine("*/");

        sb.AppendLine($"namespace {model.Namespace}");
        sb.AppendLine("{");

        // Converter class
        RenderConverterClass(sb, model);

        // Partial class extension
        RenderPartialClass(sb, model);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void RenderConverterClass(StringBuilder sb, OrdinalSerializationModel model)
    {
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Strongly-typed ordinal converter for {model.TypeName}. No reflection required.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    internal sealed class {model.TypeName}OrdinalConverter : global::System.Text.Json.Serialization.JsonConverter<{model.FullTypeName}>");
        sb.AppendLine("    {");

        // Read method
        RenderReadMethod(sb, model);

        // Write method
        RenderWriteMethod(sb, model);

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void RenderReadMethod(StringBuilder sb, OrdinalSerializationModel model)
    {
        sb.AppendLine($"        public override {model.FullTypeName}? Read(");
        sb.AppendLine("            ref global::System.Text.Json.Utf8JsonReader reader,");
        sb.AppendLine("            global::System.Type typeToConvert,");
        sb.AppendLine("            global::System.Text.Json.JsonSerializerOptions options)");
        sb.AppendLine("        {");

        sb.AppendLine("            if (reader.TokenType == global::System.Text.Json.JsonTokenType.Null)");
        sb.AppendLine("                return null;");
        sb.AppendLine();

        sb.AppendLine("            if (reader.TokenType != global::System.Text.Json.JsonTokenType.StartArray)");
        sb.AppendLine($"                throw new global::System.Text.Json.JsonException(");
        sb.AppendLine($"                    $\"Expected StartArray for {model.TypeName} ordinal format, got {{reader.TokenType}}\");");
        sb.AppendLine();

        sb.AppendLine("            reader.Read(); // Move past StartArray");
        sb.AppendLine();

        // Read each property
        for (int i = 0; i < model.Properties.Count; i++)
        {
            var prop = model.Properties[i];
            // For nullable types, append ? to the type for proper null handling.
            // Nullable value types (int?) need Deserialize<int?> to handle null values.
            // TrimEnd ensures no trailing whitespace in the type string.
            var baseType = prop.Type.TrimEnd();
            var deserializeType = prop.IsNullable ? $"{baseType}?" : baseType;
            sb.AppendLine($"            // {prop.Name} ({deserializeType}) - position {i}");
            sb.AppendLine($"            var prop{i} = global::System.Text.Json.JsonSerializer.Deserialize<{deserializeType}>(ref reader, options);");
            sb.AppendLine("            reader.Read();");
        }

        sb.AppendLine();
        sb.AppendLine("            if (reader.TokenType != global::System.Text.Json.JsonTokenType.EndArray)");
        sb.AppendLine($"                throw new global::System.Text.Json.JsonException(");
        sb.AppendLine($"                    $\"Too many values in ordinal array for {model.TypeName}. Expected {model.Properties.Count}.\");");
        sb.AppendLine();

        // Construct the object
        RenderConstruction(sb, model, "prop");

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void RenderWriteMethod(StringBuilder sb, OrdinalSerializationModel model)
    {
        sb.AppendLine("        public override void Write(");
        sb.AppendLine("            global::System.Text.Json.Utf8JsonWriter writer,");
        sb.AppendLine($"            {model.FullTypeName} value,");
        sb.AppendLine("            global::System.Text.Json.JsonSerializerOptions options)");
        sb.AppendLine("        {");

        sb.AppendLine("            if (value == null)");
        sb.AppendLine("            {");
        sb.AppendLine("                writer.WriteNullValue();");
        sb.AppendLine("                return;");
        sb.AppendLine("            }");
        sb.AppendLine();

        sb.AppendLine("            writer.WriteStartArray();");

        // Write each property
        for (int i = 0; i < model.Properties.Count; i++)
        {
            var prop = model.Properties[i];
            sb.AppendLine($"            global::System.Text.Json.JsonSerializer.Serialize(writer, value.{prop.Name}, options);");
        }

        sb.AppendLine("            writer.WriteEndArray();");
        sb.AppendLine("        }");
    }

    private static void RenderPartialClass(StringBuilder sb, OrdinalSerializationModel model)
    {
        var recordKeyword = model.IsRecord ? "record" : "class";

        sb.AppendLine($"    partial {recordKeyword} {model.TypeName} : global::Neatoo.RemoteFactory.IOrdinalSerializable, global::Neatoo.RemoteFactory.IOrdinalSerializationMetadata, global::Neatoo.RemoteFactory.IOrdinalConverterProvider<{model.FullTypeName}>");
        sb.AppendLine("    {");

        // PropertyNames static property
        var propertyNamesArray = string.Join(", ", model.Properties.Select(p => $"\"{p.Name}\""));
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Property names in ordinal order (alphabetical, base properties first).");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static string[] PropertyNames {{ get; }} = new[] {{ {propertyNamesArray} }};");
        sb.AppendLine();

        // PropertyTypes static property
        // Note: Nullable annotations are already stripped at the source (FactoryGenerator.Types.cs)
        // using WithNullableAnnotation(NullableAnnotation.NotAnnotated) to avoid CS8639 errors.
        var propertyTypesArray = string.Join(", ", model.Properties.Select(p => $"typeof({p.Type})"));
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Property types in ordinal order.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static Type[] PropertyTypes {{ get; }} = new[] {{ {propertyTypesArray} }};");
        sb.AppendLine();

        // ToOrdinalArray method
        var toArrayValues = string.Join(", ", model.Properties.Select(p => $"this.{p.Name}"));
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Converts this instance to an ordinal array for compact JSON serialization.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public object?[] ToOrdinalArray()");
        sb.AppendLine("        {");
        sb.AppendLine($"            return new object?[] {{ {toArrayValues} }};");
        sb.AppendLine("        }");
        sb.AppendLine();

        // FromOrdinalArray static method
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an instance from an ordinal array.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static object FromOrdinalArray(object?[] values)");
        sb.AppendLine("        {");
        RenderFromOrdinalArrayConstruction(sb, model);
        sb.AppendLine("        }");
        sb.AppendLine();

        // CreateOrdinalConverter static method
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Creates an AOT-compatible ordinal converter for this type.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static global::System.Text.Json.Serialization.JsonConverter<{model.FullTypeName}> CreateOrdinalConverter()");
        sb.AppendLine($"            => new {model.TypeName}OrdinalConverter();");

        sb.AppendLine("    }");
    }

    private static void RenderConstruction(StringBuilder sb, OrdinalSerializationModel model, string propPrefix)
    {
        if (model.IsRecord && model.HasPrimaryConstructor && model.ConstructorParameterNames.Count > 0)
        {
            // For records with primary constructors, use constructor syntax
            var constructorArgs = BuildConstructorArgs(model, propPrefix);
            sb.AppendLine($"            return new {model.FullTypeName}({constructorArgs});");
        }
        else
        {
            // For classes and records without primary constructors, use object initializer
            sb.AppendLine($"            return new {model.FullTypeName}");
            sb.AppendLine("            {");

            for (int i = 0; i < model.Properties.Count; i++)
            {
                var prop = model.Properties[i];
                var isEffectivelyNullable = prop.IsNullable || prop.Type.EndsWith("?");
                var nullForgiving = isEffectivelyNullable ? "" : "!";
                var comma = i < model.Properties.Count - 1 ? "," : "";
                sb.AppendLine($"                {prop.Name} = {propPrefix}{i}{nullForgiving}{comma}");
            }

            sb.AppendLine("            };");
        }
    }

    private static void RenderFromOrdinalArrayConstruction(StringBuilder sb, OrdinalSerializationModel model)
    {
        if (model.IsRecord && model.HasPrimaryConstructor && model.ConstructorParameterNames.Count > 0)
        {
            // For records with primary constructors, use constructor syntax
            var constructorArgs = BuildConstructorArgsForFromArray(model);
            sb.AppendLine($"            return new {model.TypeName}({constructorArgs});");
        }
        else
        {
            // For classes and records without primary constructors, use object initializer
            sb.AppendLine($"            return new {model.TypeName}");
            sb.AppendLine("            {");

            for (int i = 0; i < model.Properties.Count; i++)
            {
                var prop = model.Properties[i];
                // For nullable types, add ? to the cast type to avoid CS8600
                // when casting from object? to a non-nullable type.
                // TrimEnd ensures no trailing whitespace in the type string.
                // Defensive: only add ? if type doesn't already end with ? (shouldn't happen after source fix).
                var baseType = prop.Type.TrimEnd();
                var needsNullableSuffix = prop.IsNullable && !baseType.EndsWith("?");
                var castType = needsNullableSuffix ? $"{baseType}?" : baseType;
                var cast = $"({castType})";
                var nullForgiving = prop.IsNullable ? "" : "!";
                var comma = i < model.Properties.Count - 1 ? "," : "";
                sb.AppendLine($"                {prop.Name} = {cast}values[{i}]{nullForgiving}{comma}");
            }

            sb.AppendLine("            };");
        }
    }

    private static string BuildConstructorArgs(OrdinalSerializationModel model, string propPrefix)
    {
        var args = new List<string>();

        // Build a mapping from property name to its index
        var propertyToIndex = new Dictionary<string, int>();
        for (int i = 0; i < model.Properties.Count; i++)
        {
            propertyToIndex[model.Properties[i].Name] = i;
        }

        // Arguments must be in constructor parameter order
        foreach (var paramName in model.ConstructorParameterNames)
        {
            if (propertyToIndex.TryGetValue(paramName, out var idx))
            {
                var prop = model.Properties[idx];
                var isEffectivelyNullable = prop.IsNullable || prop.Type.EndsWith("?");
                var nullForgiving = isEffectivelyNullable ? "" : "!";
                args.Add($"{propPrefix}{idx}{nullForgiving}");
            }
        }

        return string.Join(", ", args);
    }

    private static string BuildConstructorArgsForFromArray(OrdinalSerializationModel model)
    {
        var args = new List<string>();

        // Build a mapping from property name to its index
        var propertyToIndex = new Dictionary<string, int>();
        for (int i = 0; i < model.Properties.Count; i++)
        {
            propertyToIndex[model.Properties[i].Name] = i;
        }

        // Arguments must be in constructor parameter order
        foreach (var paramName in model.ConstructorParameterNames)
        {
            if (propertyToIndex.TryGetValue(paramName, out var idx))
            {
                var prop = model.Properties[idx];
                // For nullable types, add ? to the cast type to avoid CS8600
                // when casting from object? to a non-nullable type.
                // TrimEnd ensures no trailing whitespace in the type string.
                // Defensive: only add ? if type doesn't already end with ? (shouldn't happen after source fix).
                var baseType = prop.Type.TrimEnd();
                var needsNullableSuffix = prop.IsNullable && !baseType.EndsWith("?");
                var castType = needsNullableSuffix ? $"{baseType}?" : baseType;
                var cast = $"({castType.TrimEnd()})";  // Extra TrimEnd for safety
                var nullForgiving = prop.IsNullable ? "" : "!";
                args.Add($"{cast}values[{idx}]{nullForgiving}");
            }
        }

        return string.Join(", ", args);
    }
}
