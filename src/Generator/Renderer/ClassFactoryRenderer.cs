// src/Generator/Renderer/ClassFactoryRenderer.cs
// Renders factories for classes and records with the [Factory] attribute.

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Neatoo.RemoteFactory.FactoryGenerator;
using Neatoo.RemoteFactory.Generator.Model;

namespace Neatoo.RemoteFactory.Generator.Renderer;

/// <summary>
/// Renders factory code for classes and records with the [Factory] attribute.
/// </summary>
internal static class ClassFactoryRenderer
{
    /// <summary>
    /// Renders the complete factory source code for a class/record.
    /// </summary>
    public static string Render(FactoryGenerationUnit unit)
    {
        var model = unit.ClassFactory!;
        var mode = unit.Mode;

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Using statements
        foreach (var u in unit.Usings)
        {
            sb.AppendLine(u);
        }

        // Add hosting using if there are events
        if (model.Events.Count > 0 && model.IsPartial)
        {
            sb.AppendLine("using Microsoft.Extensions.Hosting;");
        }

        sb.AppendLine();
        sb.AppendLine("/*");
        sb.AppendLine("    READONLY - DO NOT EDIT!!!!");
        sb.AppendLine("    Generated by Neatoo.RemoteFactory");
        sb.AppendLine("*/");

        sb.AppendLine($"namespace {unit.Namespace}");
        sb.AppendLine("{");

        // Event partial class (if there are events and the class is partial)
        if (model.Events.Count > 0 && model.IsPartial)
        {
            RenderEventPartialClass(sb, model);
        }

        // Factory interface
        RenderFactoryInterface(sb, model);

        // Factory class
        RenderFactoryClass(sb, model, mode);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void RenderEventPartialClass(StringBuilder sb, ClassFactoryModel model)
    {
        sb.AppendLine($"    // Event delegates for {model.ImplementationTypeName}");
        sb.AppendLine($"    public partial class {model.ImplementationTypeName}");
        sb.AppendLine("    {");

        foreach (var evt in model.Events)
        {
            var paramDecl = string.Join(", ", evt.Parameters
                .Where(p => !p.IsCancellationToken)
                .Select(p => $"{p.Type} {p.Name}"));

            sb.AppendLine($"        public delegate Task {evt.DelegateName}({paramDecl});");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void RenderFactoryInterface(StringBuilder sb, ClassFactoryModel model)
    {
        sb.AppendLine($"    public interface I{model.ImplementationTypeName}Factory");
        sb.AppendLine("    {");

        foreach (var method in model.Methods)
        {
            var interfaceMethod = RenderInterfaceMethodSignature(method);
            if (!string.IsNullOrEmpty(interfaceMethod))
            {
                sb.AppendLine($"        {interfaceMethod}");
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string RenderInterfaceMethodSignature(FactoryMethodModel method)
    {
        // Skip write methods as they're only used internally by Save
        if (method is WriteMethodModel)
        {
            return string.Empty;
        }

        var returnType = GetReturnType(method, includeTask: true, includeAuth: false);
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);

        var result = $"{returnType} {method.Name}({parameters});";

        // For Save methods with auth, also add TrySave interface method
        if (method is SaveMethodModel sm && sm.HasAuth)
        {
            var authReturnType = GetReturnType(method, includeTask: true, includeAuth: true);
            result += $"\n        {authReturnType} Try{method.Name}({parameters});";
        }

        return result;
    }

    private static void RenderFactoryClass(StringBuilder sb, ClassFactoryModel model, FactoryMode mode)
    {
        // Determine base class
        var baseClass = model.HasDefaultSave ? "FactorySaveBase" : "FactoryBase";
        var implementsInterfaces = model.HasDefaultSave
            ? $", IFactorySave<{model.ImplementationTypeName}>, I{model.ImplementationTypeName}Factory"
            : $", I{model.ImplementationTypeName}Factory";

        sb.AppendLine($"    internal class {model.ImplementationTypeName}Factory : {baseClass}<{model.ServiceTypeName}>{implementsInterfaces}");
        sb.AppendLine("    {");

        // Fields
        sb.AppendLine("        private readonly IServiceProvider ServiceProvider;");

        if (mode == FactoryMode.RemoteOnly)
        {
            sb.AppendLine("        private readonly IMakeRemoteDelegateRequest MakeRemoteDelegateRequest;");
        }
        else
        {
            sb.AppendLine("        private readonly IMakeRemoteDelegateRequest? MakeRemoteDelegateRequest;");
        }

        sb.AppendLine();

        // Delegates
        sb.AppendLine("        // Delegates");
        foreach (var method in model.Methods.Where(m => m.IsRemote && !(m is WriteMethodModel)))
        {
            RenderDelegate(sb, method);
        }
        sb.AppendLine();

        // Delegate properties
        sb.AppendLine("        // Delegate Properties to provide Local or Remote fork in execution");
        foreach (var method in model.Methods.Where(m => m.IsRemote && !(m is WriteMethodModel)))
        {
            RenderDelegateProperty(sb, method);
        }
        sb.AppendLine();

        // Constructors
        RenderConstructors(sb, model, mode);

        // Methods
        foreach (var method in model.Methods)
        {
            if (method is WriteMethodModel wm)
            {
                // Write methods only get LocalMethod generated (in Full mode)
                if (mode == FactoryMode.Full || !method.IsRemote)
                {
                    RenderLocalMethod(sb, wm, model, mode);
                }
            }
            else if (method is SaveMethodModel sm)
            {
                RenderSaveMethod(sb, sm, model, mode);
            }
            else if (method is ReadMethodModel rm)
            {
                RenderReadMethod(sb, rm, model, mode);
            }
            else if (method is CanMethodModel cm)
            {
                RenderCanMethod(sb, cm, model, mode);
            }
        }

        // FactoryServiceRegistrar
        RenderFactoryServiceRegistrar(sb, model, mode);

        sb.AppendLine("    }");
    }

    #region Delegate Rendering

    private static void RenderDelegate(StringBuilder sb, FactoryMethodModel method)
    {
        var returnType = GetReturnType(method, includeTask: true, includeAuth: true);
        // Delegate signature excludes services - they're injected in LocalMethod
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);

        sb.AppendLine($"        public delegate {returnType} {method.UniqueName}Delegate({parameters});");
    }

    private static void RenderDelegateProperty(StringBuilder sb, FactoryMethodModel method)
    {
        sb.AppendLine($"        public {method.UniqueName}Delegate {method.UniqueName}Property {{ get; }}");
    }

    #endregion

    #region Constructor Rendering

    private static void RenderConstructors(StringBuilder sb, ClassFactoryModel model, FactoryMode mode)
    {
        if (mode == FactoryMode.RemoteOnly)
        {
            // RemoteOnly mode: Only generate remote constructor
            sb.AppendLine($"        public {model.ImplementationTypeName}Factory(IServiceProvider serviceProvider, IMakeRemoteDelegateRequest remoteMethodDelegate, IFactoryCore<{model.ServiceTypeName}> factoryCore) : base(factoryCore)");
            sb.AppendLine("        {");
            sb.AppendLine("            this.ServiceProvider = serviceProvider;");
            sb.AppendLine("            this.MakeRemoteDelegateRequest = remoteMethodDelegate;");

            // Remote property assignments
            foreach (var method in model.Methods.Where(m => m.IsRemote && !(m is WriteMethodModel)))
            {
                sb.AppendLine($"            {method.UniqueName}Property = Remote{method.UniqueName};");
            }

            sb.AppendLine("        }");
        }
        else
        {
            // Full mode: Generate both constructors
            // Local constructor
            sb.AppendLine($"        public {model.ImplementationTypeName}Factory(IServiceProvider serviceProvider, IFactoryCore<{model.ServiceTypeName}> factoryCore) : base(factoryCore)");
            sb.AppendLine("        {");
            sb.AppendLine("            this.ServiceProvider = serviceProvider;");

            // Local property assignments
            foreach (var method in model.Methods.Where(m => m.IsRemote && !(m is WriteMethodModel)))
            {
                sb.AppendLine($"            {method.UniqueName}Property = Local{method.UniqueName};");
            }

            sb.AppendLine("        }");
            sb.AppendLine();

            // Remote constructor
            sb.AppendLine($"        public {model.ImplementationTypeName}Factory(IServiceProvider serviceProvider, IMakeRemoteDelegateRequest remoteMethodDelegate, IFactoryCore<{model.ServiceTypeName}> factoryCore) : base(factoryCore)");
            sb.AppendLine("        {");
            sb.AppendLine("            this.ServiceProvider = serviceProvider;");
            sb.AppendLine("            this.MakeRemoteDelegateRequest = remoteMethodDelegate;");

            // Remote property assignments
            foreach (var method in model.Methods.Where(m => m.IsRemote && !(m is WriteMethodModel)))
            {
                sb.AppendLine($"            {method.UniqueName}Property = Remote{method.UniqueName};");
            }

            sb.AppendLine("        }");
        }

        sb.AppendLine();
    }

    #endregion

    #region Read Method Rendering

    private static void RenderReadMethod(StringBuilder sb, ReadMethodModel method, ClassFactoryModel model, FactoryMode mode)
    {
        // Public method
        RenderPublicMethod(sb, method);

        // Remote method (if remote)
        if (method.IsRemote)
        {
            RenderRemoteMethod(sb, method);
        }

        // Local method (in Full mode, or for non-remote methods)
        if (mode == FactoryMode.Full || !method.IsRemote)
        {
            RenderReadLocalMethod(sb, method, model);
        }
    }

    private static void RenderPublicMethod(StringBuilder sb, FactoryMethodModel method)
    {
        var hasAuth = method.HasAuth;
        var asyncKeyword = method.IsTask && hasAuth ? "async" : "";
        var awaitKeyword = method.IsTask && hasAuth ? "await" : "";
        var returnType = GetReturnType(method, includeTask: true, includeAuth: false);
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);
        var paramIdentifiers = GetParameterIdentifiersWithCancellationToken(method.Parameters, includeServices: false);

        sb.AppendLine($"        public virtual {asyncKeyword} {returnType} {method.Name}({parameters})");
        sb.AppendLine("        {");

        var methodTarget = method.IsRemote ? $"{method.UniqueName}Property" : $"Local{method.UniqueName}";

        if (!hasAuth)
        {
            sb.AppendLine($"            return {methodTarget}({paramIdentifiers});");
        }
        else
        {
            sb.AppendLine($"            return ({awaitKeyword} {methodTarget}({paramIdentifiers})).Result;");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void RenderRemoteMethod(StringBuilder sb, FactoryMethodModel method)
    {
        var returnType = GetReturnType(method, includeTask: true, includeAuth: true);
        var returnTypeWithoutTask = GetReturnType(method, includeTask: false, includeAuth: true);
        // Remote method signature excludes services
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);
        var nullableText = returnTypeWithoutTask.EndsWith("?") ? "Nullable" : "";

        // Exclude CancellationToken from serialized parameters
        var serializedParams = string.Join(", ", method.Parameters
            .Where(p => !p.IsService && !p.IsCancellationToken)
            .Select(p => p.Name));

        sb.AppendLine($"        public virtual async {returnType} Remote{method.UniqueName}({parameters})");
        sb.AppendLine("        {");
        sb.AppendLine($"            return (await MakeRemoteDelegateRequest!.ForDelegate{nullableText}<{returnTypeWithoutTask}>(typeof({method.UniqueName}Delegate), [{serializedParams}], cancellationToken))!;");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void RenderReadLocalMethod(StringBuilder sb, ReadMethodModel method, ClassFactoryModel model)
    {
        var asyncKeyword = method.IsAsync ? "async" : "";
        var returnType = GetReturnType(method, includeTask: true, includeAuth: true);
        // Local method signature excludes services - they're obtained via ServiceProvider inside
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);

        sb.AppendLine($"        public {asyncKeyword} {returnType} Local{method.UniqueName}({parameters})");
        sb.AppendLine("        {");

        // Authorization checks
        RenderAuthorizationChecks(sb, method);

        // Get target if not constructor or static factory
        if (!method.IsConstructor && !method.IsStaticFactory)
        {
            sb.AppendLine($"            var target = ServiceProvider.GetRequiredService<{model.ImplementationTypeName}>();");
        }

        // Service assignments
        RenderServiceAssignments(sb, method.Parameters);

        // Method call
        var methodCall = BuildDoFactoryMethodCall(method, model);
        sb.AppendLine($"            return {methodCall};");

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string BuildDoFactoryMethodCall(ReadMethodModel method, ClassFactoryModel model)
    {
        var callMethod = "DoFactoryMethodCall";

        if (method.IsBool)
        {
            callMethod += "Bool";
        }

        // Use IsDomainMethodTask (underlying method's async status) not IsTask (factory method's return type)
        if (method.IsDomainMethodTask)
        {
            callMethod += "Async";
            if (method.IsDomainMethodNullable)
            {
                callMethod += "Nullable";
            }
        }

        // Build domain method invocation parameters
        var domainParams = GetParameterIdentifiersForDomainInvocation(method.Parameters);

        string factoryCall;
        if (method.IsConstructor)
        {
            factoryCall = $"{callMethod}(FactoryOperation.{method.Operation}, () => new {model.ImplementationTypeName}({domainParams}))";
        }
        else if (method.IsStaticFactory)
        {
            factoryCall = $"{callMethod}(FactoryOperation.{method.Operation}, () => {model.ImplementationTypeName}.{method.Name}({domainParams}))";
        }
        else
        {
            factoryCall = $"{callMethod}(target, FactoryOperation.{method.Operation}, () => target.{method.Name}({domainParams}))";
        }

        // Add await if factory method is async AND domain method returns Task
        if (method.IsAsync && method.IsDomainMethodTask)
        {
            factoryCall = $"await {factoryCall}";
        }

        if (method.HasAuth)
        {
            factoryCall = $"new Authorized<{model.ServiceTypeName}>({factoryCall})";
        }

        // Wrap in Task.FromResult if domain method doesn't return Task but factory method needs to
        if (!method.IsDomainMethodTask && method.IsTask && !method.IsAsync)
        {
            factoryCall = $"Task.FromResult({factoryCall})";
        }

        return factoryCall;
    }

    #endregion

    #region Write Method Rendering

    private static void RenderLocalMethod(StringBuilder sb, WriteMethodModel method, ClassFactoryModel model, FactoryMode mode)
    {
        var asyncKeyword = method.IsAsync ? "async" : "";
        var returnType = GetReturnType(method, includeTask: true, includeAuth: true);
        // Local method signature excludes services - they're obtained via ServiceProvider inside
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);

        sb.AppendLine($"        public {asyncKeyword} {returnType} Local{method.UniqueName}({parameters})");
        sb.AppendLine("        {");

        // Authorization checks
        RenderAuthorizationChecks(sb, method);

        // Cast target
        sb.AppendLine($"            var cTarget = ({model.ImplementationTypeName}) target ?? throw new Exception(\"{model.ServiceTypeName} must implement {model.ImplementationTypeName}\");");

        // Service assignments
        RenderServiceAssignments(sb, method.Parameters);

        // Method call
        var methodCall = BuildWriteDoFactoryMethodCall(method, model);
        sb.AppendLine($"            return {methodCall};");

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string BuildWriteDoFactoryMethodCall(WriteMethodModel method, ClassFactoryModel model)
    {
        var callMethod = "DoFactoryMethodCall";

        // Add Bool suffix if domain method returns bool
        if (method.IsBool)
        {
            callMethod += "Bool";
        }

        // Use IsDomainMethodTask (underlying method's async status) not IsTask (factory method's return type)
        if (method.IsDomainMethodTask)
        {
            callMethod += "Async";
        }

        // Build domain method invocation parameters
        var domainParams = GetParameterIdentifiersForDomainInvocation(method.Parameters);

        var factoryCall = $"{callMethod}(cTarget, FactoryOperation.{method.Operation}, () => cTarget.{method.Name}({domainParams}))";

        // Add await if factory method is async AND domain method returns Task
        if (method.IsAsync && method.IsDomainMethodTask)
        {
            factoryCall = $"await {factoryCall}";
        }

        if (method.HasAuth)
        {
            factoryCall = $"new Authorized<{model.ServiceTypeName}>({factoryCall})";
        }

        // Wrap in Task.FromResult if domain method doesn't return Task but factory method needs to
        if (!method.IsDomainMethodTask && method.IsTask && !method.IsAsync)
        {
            factoryCall = $"Task.FromResult({factoryCall})";
        }

        return factoryCall;
    }

    #endregion

    #region Save Method Rendering

    private static void RenderSaveMethod(StringBuilder sb, SaveMethodModel method, ClassFactoryModel model, FactoryMode mode)
    {
        // Public method (with auth handling)
        RenderSavePublicMethod(sb, method, model);

        // Remote method (if remote)
        if (method.IsRemote)
        {
            RenderRemoteMethod(sb, method);
        }

        // Local method (in Full mode, or for non-remote methods)
        if (mode == FactoryMode.Full || !method.IsRemote)
        {
            RenderSaveLocalMethod(sb, method, model);
        }

        // Explicit interface method (always needed)
        RenderSaveExplicitInterfaceMethod(sb, method, model);
    }

    private static void RenderSavePublicMethod(StringBuilder sb, SaveMethodModel method, ClassFactoryModel model)
    {
        var hasAuth = method.HasAuth;
        var returnType = GetReturnType(method, includeTask: true, includeAuth: false);
        // Public method excludes services - they're injected in the local method
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);
        var paramIdentifiers = GetParameterIdentifiersWithCancellationToken(method.Parameters, includeServices: false);

        var methodTarget = method.IsRemote ? $"{method.UniqueName}Property" : $"Local{method.UniqueName}";

        if (!hasAuth)
        {
            var asyncKeyword = method.IsTask ? "" : "";
            sb.AppendLine($"        public virtual {asyncKeyword} {returnType} {method.Name}({parameters})");
            sb.AppendLine("        {");
            sb.AppendLine($"            return {methodTarget}({paramIdentifiers});");
            sb.AppendLine("        }");
        }
        else
        {
            var asyncKeyword = method.IsTask ? "async" : "";
            var awaitKeyword = method.IsTask ? "await" : "";

            sb.AppendLine($"        public virtual {asyncKeyword} {returnType} {method.Name}({parameters})");
            sb.AppendLine("        {");
            sb.AppendLine($"            var authorized = ({awaitKeyword} {methodTarget}({paramIdentifiers}));");
            sb.AppendLine("            if (!authorized.HasAccess)");
            sb.AppendLine("            {");
            sb.AppendLine("                throw new NotAuthorizedException(authorized);");
            sb.AppendLine("            }");
            sb.AppendLine("            return authorized.Result;");
            sb.AppendLine("        }");
            sb.AppendLine();

            // TrySave method
            var authReturnType = GetReturnType(method, includeTask: true, includeAuth: true);
            var asyncKeyword2 = method.IsAsync ? "async" : "";
            var awaitKeyword2 = method.IsAsync ? "await" : "";

            sb.AppendLine($"        public virtual {asyncKeyword2} {authReturnType} Try{method.Name}({parameters})");
            sb.AppendLine("        {");
            sb.AppendLine($"            return {awaitKeyword2} {methodTarget}({paramIdentifiers});");
            sb.AppendLine("        }");
        }

        sb.AppendLine();
    }

    private static void RenderSaveLocalMethod(StringBuilder sb, SaveMethodModel method, ClassFactoryModel model)
    {
        var asyncKeyword = method.IsAsync ? "async" : "";
        var returnType = GetReturnType(method, includeTask: true, includeAuth: true);
        // Local method signature excludes services - they're obtained via ServiceProvider inside
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);
        var paramIdentifiers = GetParameterIdentifiersWithCancellationToken(method.Parameters, includeServices: false);

        sb.AppendLine($"        public virtual {asyncKeyword} {returnType} Local{method.UniqueName}({parameters})");
        sb.AppendLine("        {");

        // Default return value
        var defaultReturn = method.HasAuth
            ? $"new Authorized<{model.ServiceTypeName}>()"
            : $"default({model.ServiceTypeName})";

        if (method.IsTask && !method.IsAsync)
        {
            defaultReturn = $"Task.FromResult({defaultReturn})";
        }

        // Delete branch
        sb.AppendLine("            if (target.IsDeleted)");
        sb.AppendLine("            {");
        if (method.DeleteMethod != null)
        {
            var deleteCall = BuildSaveBranchCall(method, method.DeleteMethod, paramIdentifiers);
            sb.AppendLine($"                if (target.IsNew) {{ return {defaultReturn}; }}");
            sb.AppendLine($"                return {deleteCall};");
        }
        else
        {
            sb.AppendLine("                throw new NotImplementedException();");
        }
        sb.AppendLine("            }");

        // Insert branch
        sb.AppendLine("            else if (target.IsNew)");
        sb.AppendLine("            {");
        if (method.InsertMethod != null)
        {
            var insertCall = BuildSaveBranchCall(method, method.InsertMethod, paramIdentifiers);
            sb.AppendLine($"                return {insertCall};");
        }
        else
        {
            sb.AppendLine("                throw new NotImplementedException();");
        }
        sb.AppendLine("            }");

        // Update branch
        sb.AppendLine("            else");
        sb.AppendLine("            {");
        if (method.UpdateMethod != null)
        {
            var updateCall = BuildSaveBranchCall(method, method.UpdateMethod, paramIdentifiers);
            sb.AppendLine($"                return {updateCall};");
        }
        else
        {
            sb.AppendLine("                throw new NotImplementedException();");
        }
        sb.AppendLine("            }");

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string BuildSaveBranchCall(SaveMethodModel saveMethod, WriteMethodModel branchMethod, string _unused)
    {
        // Map branch method parameters to save method parameters
        // Branch method may have different parameter names but same types
        var branchParams = branchMethod.Parameters.Where(p => !p.IsService && !p.IsCancellationToken).ToList();
        var saveParams = saveMethod.Parameters.Where(p => !p.IsService && !p.IsCancellationToken).ToList();

        var paramList = new List<string>();

        // Add target
        if (branchMethod.Parameters.Any(p => p.IsTarget))
        {
            paramList.Add("target");
        }

        // Map branch method's non-target parameters to save method's parameters by position
        var branchNonTarget = branchParams.Where(p => !p.IsTarget).ToList();
        var saveNonTarget = saveParams.Where(p => !p.IsTarget).ToList();

        for (int i = 0; i < branchNonTarget.Count && i < saveNonTarget.Count; i++)
        {
            // Use save method's parameter name (which is in scope)
            paramList.Add(saveNonTarget[i].Name);
        }

        // Always add cancellation token - Local methods always have this parameter
        // (added by GetParameterDeclarationsWithOptionalCancellationToken)
        paramList.Add("cancellationToken");

        var methodCall = $"Local{branchMethod.UniqueName}({string.Join(", ", paramList)})";

        // Add await if save method is async AND branch method returns Task (IsTask, not IsDomainMethodTask)
        if (saveMethod.IsAsync && branchMethod.IsTask)
        {
            methodCall = $"await {methodCall}";
        }

        if (saveMethod.HasAuth && !branchMethod.HasAuth)
        {
            methodCall = $"new Authorized<{saveMethod.ServiceType}>({methodCall})";
        }

        // Wrap in Task.FromResult if branch local method doesn't return Task but save method needs to
        // Use branchMethod.IsTask (local method return type), not IsDomainMethodTask (domain method)
        if (!branchMethod.IsTask && saveMethod.IsTask && !saveMethod.IsAsync)
        {
            methodCall = $"Task.FromResult({methodCall})";
        }

        // Handle nullability mismatch: if save is nullable but branch isn't, add null-forgiving cast
        // This happens when SaveMethod.IsNullable (due to Delete) but WriteMethod.IsNullable is false
        if (saveMethod.IsNullable && !branchMethod.IsNullable && !saveMethod.HasAuth)
        {
            // Cast to nullable to satisfy the return type
            methodCall = $"({methodCall})!";
        }

        return methodCall;
    }

    private static void RenderSaveExplicitInterfaceMethod(StringBuilder sb, SaveMethodModel method, ClassFactoryModel model)
    {
        if (!method.IsDefault)
        {
            return;
        }

        sb.AppendLine($"        async Task<IFactorySaveMeta?> IFactorySave<{model.ImplementationTypeName}>.Save({model.ImplementationTypeName} target, CancellationToken cancellationToken)");
        sb.AppendLine("        {");

        if (method.IsTask)
        {
            sb.AppendLine($"            return (IFactorySaveMeta?) await {method.Name}(target, cancellationToken);");
        }
        else
        {
            sb.AppendLine($"            return await Task.FromResult((IFactorySaveMeta?) {method.Name}(target, cancellationToken));");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    #endregion

    #region Can Method Rendering

    private static void RenderCanMethod(StringBuilder sb, CanMethodModel method, ClassFactoryModel model, FactoryMode mode)
    {
        var returnType = method.IsTask ? "Task<Authorized>" : "Authorized";
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);
        var paramIdentifiers = GetParameterIdentifiersWithCancellationToken(method.Parameters, includeServices: false);

        // Public method
        sb.AppendLine($"        public virtual {returnType} {method.UniqueName}({parameters})");
        sb.AppendLine("        {");

        var methodTarget = method.IsRemote ? $"{method.UniqueName}Property" : $"Local{method.UniqueName}";
        sb.AppendLine($"            return {methodTarget}({paramIdentifiers});");

        sb.AppendLine("        }");
        sb.AppendLine();

        // Remote method (if remote)
        if (method.IsRemote)
        {
            RenderCanRemoteMethod(sb, method);
        }

        // Local method (in Full mode, or for non-remote methods)
        if (mode == FactoryMode.Full || !method.IsRemote)
        {
            RenderCanLocalMethod(sb, method, model);
        }
    }

    private static void RenderCanRemoteMethod(StringBuilder sb, CanMethodModel method)
    {
        var returnType = method.IsTask ? "Task<Authorized>" : "Authorized";
        // Remote method signature excludes services
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);

        // Exclude CancellationToken from serialized parameters
        var serializedParams = string.Join(", ", method.Parameters
            .Where(p => !p.IsService && !p.IsCancellationToken)
            .Select(p => p.Name));

        sb.AppendLine($"        public virtual async {returnType} Remote{method.UniqueName}({parameters})");
        sb.AppendLine("        {");
        sb.AppendLine($"            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof({method.UniqueName}Delegate), [{serializedParams}], cancellationToken))!;");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void RenderCanLocalMethod(StringBuilder sb, CanMethodModel method, ClassFactoryModel model)
    {
        var asyncKeyword = method.IsAsync ? "async" : "";
        var returnType = method.IsTask ? "Task<Authorized>" : "Authorized";
        // Local method signature excludes services - they're obtained via ServiceProvider inside
        var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);

        sb.AppendLine($"        public {asyncKeyword} {returnType} Local{method.UniqueName}({parameters})");
        sb.AppendLine("        {");

        // Authorization checks
        RenderAuthorizationChecks(sb, method);

        // Return success
        var returnText = "new Authorized(true)";
        if (method.IsTask && !method.IsAsync)
        {
            returnText = $"Task.FromResult({returnText})";
        }

        sb.AppendLine($"            return {returnText};");

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    #endregion

    #region Authorization Rendering

    private static void RenderAuthorizationChecks(StringBuilder sb, FactoryMethodModel method)
    {
        if (!method.HasAuth || method.Authorization == null)
        {
            return;
        }

        sb.AppendLine("            Authorized authorized;");

        // Group auth methods by class
        var authMethodsByClass = method.Authorization.AuthMethods.GroupBy(m => m.ClassName);
        foreach (var authClass in authMethodsByClass)
        {
            var className = authClass.Key;
            var varName = className.ToLower();

            sb.AppendLine($"            {className} {varName} = ServiceProvider.GetRequiredService<{className}>();");

            foreach (var authMethod in authClass)
            {
                RenderAuthMethodCall(sb, method, authMethod, varName);
            }
        }

        // ASP.NET Authorize checks
        if (method.Authorization.AspAuthorize.Count > 0)
        {
            sb.AppendLine("            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();");

            var aspAuthDataList = method.Authorization.AspAuthorize.Select(asp =>
            {
                var ctorArgs = string.Join(", ", asp.ConstructorArgs);
                var namedArgs = string.Join(", ", asp.NamedArgs);
                var result = $"new AspAuthorizeData({ctorArgs})";
                if (!string.IsNullOrEmpty(namedArgs))
                {
                    result += $"{{ {namedArgs} }}";
                }
                return result;
            });

            var aspAuthDataText = string.Join(", ", aspAuthDataList);
            var aspForbid = method.Authorization.AspForbid.ToString().ToLower();
            sb.AppendLine($"            authorized = await aspAuthorized.Authorize([ {aspAuthDataText} ], {aspForbid});");

            if (!method.Authorization.AspForbid)
            {
                var returnType = GetReturnType(method, includeTask: false, includeAuth: true);
                sb.AppendLine("            if (!authorized.HasAccess)");
                sb.AppendLine("            {");
                sb.AppendLine($"                return new {returnType}(authorized);");
                sb.AppendLine("            }");
            }
        }
    }

    private static void RenderAuthMethodCall(StringBuilder sb, FactoryMethodModel factoryMethod, AuthMethodCall authMethod, string varName)
    {
        // Build parameter mapping from factory method params to auth method params
        var authParams = new List<string>();
        var factoryParams = factoryMethod.Parameters.Where(p => !p.IsTarget).ToList();

        foreach (var authParam in authMethod.Parameters)
        {
            var matchingFactoryParam = factoryParams.FirstOrDefault(p => p.Type == authParam.Type);
            if (matchingFactoryParam != null)
            {
                authParams.Add(matchingFactoryParam.Name);
                factoryParams.Remove(matchingFactoryParam);
            }
            else
            {
                authParams.Add($"/* Missing {authParam.Type} {authParam.Name} */");
            }
        }

        var paramText = string.Join(", ", authParams);
        var callText = $"{varName}.{authMethod.MethodName}({paramText})";

        if (authMethod.IsTask)
        {
            callText = $"await {callText}";
        }

        sb.AppendLine($"            authorized = {callText};");
        sb.AppendLine("            if (!authorized.HasAccess)");
        sb.AppendLine("            {");

        var aspForbid = factoryMethod.Authorization?.AspForbid ?? false;
        if (!aspForbid)
        {
            var isCanMethod = factoryMethod is CanMethodModel;
            var returnType = GetReturnType(factoryMethod, includeTask: false, includeAuth: true);

            string returnText;
            if (isCanMethod)
            {
                returnText = "authorized";
            }
            else
            {
                returnText = $"new {returnType}(authorized)";
            }

            if (!authMethod.IsTask && factoryMethod.IsTask && !factoryMethod.IsAsync)
            {
                returnText = $"Task.FromResult({returnText})";
            }

            sb.AppendLine($"                return {returnText};");
        }
        else
        {
            sb.AppendLine("                throw new NotAuthorizedException(authorized);");
        }

        sb.AppendLine("            }");
    }

    #endregion

    #region Service Registration Rendering

    private static void RenderFactoryServiceRegistrar(StringBuilder sb, ClassFactoryModel model, FactoryMode mode)
    {
        sb.AppendLine("        public static void FactoryServiceRegistrar(IServiceCollection services, NeatooFactory remoteLocal)");
        sb.AppendLine("        {");
        sb.AppendLine($"            services.AddScoped<{model.ImplementationTypeName}Factory>();");
        sb.AppendLine($"            services.AddScoped<I{model.ImplementationTypeName}Factory, {model.ImplementationTypeName}Factory>();");

        // Entity registration (only in Full mode)
        if (mode == FactoryMode.Full && model.RequiresEntityRegistration)
        {
            sb.AppendLine($"            services.AddTransient<{model.ImplementationTypeName}>();");
            if (model.ServiceTypeName != model.ImplementationTypeName)
            {
                sb.AppendLine($"            services.AddTransient<{model.ServiceTypeName}, {model.ImplementationTypeName}>();");
            }
        }

        // IFactorySave registration (only in Full mode)
        if (mode == FactoryMode.Full && model.HasDefaultSave)
        {
            sb.AppendLine($"            services.AddScoped<IFactorySave<{model.ImplementationTypeName}>, {model.ImplementationTypeName}Factory>();");
        }

        // Ordinal converter registration
        if (model.RegisterOrdinalConverter)
        {
            sb.AppendLine();
            sb.AppendLine("            // Register AOT-compatible ordinal converter");
            sb.AppendLine($"            global::Neatoo.RemoteFactory.Internal.NeatooOrdinalConverterFactory.RegisterConverter(");
            sb.AppendLine($"                {model.ImplementationTypeName}.CreateOrdinalConverter());");
        }

        // Delegate service registrations (only in Full mode)
        if (mode == FactoryMode.Full)
        {
            foreach (var method in model.Methods.Where(m => m.IsRemote && !(m is WriteMethodModel)))
            {
                // Delegate registration excludes services - matches the delegate signature
                var parameters = GetParameterDeclarationsWithOptionalCancellationToken(method.Parameters, includeServices: false);
                var paramIdentifiers = GetParameterIdentifiersWithCancellationToken(method.Parameters, includeServices: false);

                sb.AppendLine($"            services.AddScoped<{method.UniqueName}Delegate>(cc => {{");
                sb.AppendLine($"                var factory = cc.GetRequiredService<{model.ImplementationTypeName}Factory>();");
                sb.AppendLine($"                return ({parameters}) => factory.Local{method.UniqueName}({paramIdentifiers});");
                sb.AppendLine("            });");
            }
        }

        // Event registrations
        sb.AppendLine();
        sb.AppendLine("            // Event registrations");
        sb.AppendLine("            if(remoteLocal == NeatooFactory.Remote)");
        sb.AppendLine("            {");

        foreach (var evt in model.Events)
        {
            RenderRemoteEventRegistration(sb, evt, model);
        }

        sb.AppendLine("            }");
        sb.AppendLine("            if(remoteLocal == NeatooFactory.Logical || remoteLocal == NeatooFactory.Server)");
        sb.AppendLine("            {");

        foreach (var evt in model.Events)
        {
            RenderLocalEventRegistration(sb, evt, model);
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }

    private static void RenderLocalEventRegistration(StringBuilder sb, EventMethodModel evt, ClassFactoryModel model)
    {
        var paramDecl = string.Join(", ", evt.Parameters
            .Where(p => !p.IsCancellationToken)
            .Select(p => $"{p.Type} {p.Name}"));

        var allParamIdentifiers = BuildEventMethodInvocationParams(evt);

        var serviceAssignments = string.Join("\n                        ",
            evt.ServiceParameters.Select(p => $"var {p.Name} = scope.ServiceProvider.GetRequiredService<{p.Type}>();"));

        var methodInvocation = evt.IsAsync
            ? $"await handler.{evt.Name}({allParamIdentifiers});"
            : $"handler.{evt.Name}({allParamIdentifiers});";

        sb.AppendLine($"                services.AddScoped<{model.ImplementationTypeName}.{evt.DelegateName}>(sp =>");
        sb.AppendLine("                {");
        sb.AppendLine("                    var scopeFactory = sp.GetRequiredService<IServiceScopeFactory>();");
        sb.AppendLine("                    var tracker = sp.GetRequiredService<IEventTracker>();");
        sb.AppendLine("                    var lifetime = sp.GetRequiredService<IHostApplicationLifetime>();");
        sb.AppendLine($"                    return ({paramDecl}) =>");
        sb.AppendLine("                    {");
        sb.AppendLine("                        var task = Task.Run(async () =>");
        sb.AppendLine("                        {");
        sb.AppendLine("                            using var scope = scopeFactory.CreateScope();");
        sb.AppendLine("                            var ct = lifetime.ApplicationStopping;");
        sb.AppendLine($"                            var handler = scope.ServiceProvider.GetRequiredService<{model.ImplementationTypeName}>();");

        if (!string.IsNullOrEmpty(serviceAssignments))
        {
            sb.AppendLine($"                            {serviceAssignments}");
        }

        sb.AppendLine($"                            {methodInvocation}");
        sb.AppendLine("                        });");
        sb.AppendLine("                        tracker.Track(task);");
        sb.AppendLine("                        return task;");
        sb.AppendLine("                    };");
        sb.AppendLine("                });");
    }

    private static void RenderRemoteEventRegistration(StringBuilder sb, EventMethodModel evt, ClassFactoryModel model)
    {
        var paramDecl = string.Join(", ", evt.Parameters
            .Where(p => !p.IsCancellationToken)
            .Select(p => $"{p.Type} {p.Name}"));

        var serializedParams = string.Join(", ", evt.Parameters
            .Where(p => !p.IsService && !p.IsCancellationToken)
            .Select(p => p.Name));

        sb.AppendLine($"                services.AddTransient<{model.ImplementationTypeName}.{evt.DelegateName}>(cc =>");
        sb.AppendLine("                {");
        sb.AppendLine($"                    return ({paramDecl}) => cc.GetRequiredService<IMakeRemoteDelegateRequest>().ForDelegateEvent(typeof({model.ImplementationTypeName}.{evt.DelegateName}), [{serializedParams}]);");
        sb.AppendLine("                });");
    }

    #endregion

    #region Service Assignment Rendering

    private static void RenderServiceAssignments(StringBuilder sb, IReadOnlyList<ParameterModel> parameters)
    {
        foreach (var param in parameters.Where(p => p.IsService))
        {
            sb.AppendLine($"            var {param.Name} = ServiceProvider.GetRequiredService<{param.Type}>();");
        }
    }

    #endregion

    #region Helper Methods

    private static string GetReturnType(FactoryMethodModel method, bool includeTask, bool includeAuth)
    {
        var returnType = method.ServiceType;

        if (method is CanMethodModel)
        {
            returnType = "Authorized";
        }
        else if (method.HasAuth && includeAuth)
        {
            returnType = $"Authorized<{returnType}>";
        }
        else if (method.IsNullable)
        {
            returnType = $"{returnType}?";
        }

        if (includeTask && method.IsTask)
        {
            returnType = $"Task<{returnType}>";
        }

        return returnType;
    }

    private static string GetParameterDeclarationsWithOptionalCancellationToken(IReadOnlyList<ParameterModel> parameters, bool includeServices = true, bool includeTarget = true)
    {
        var paramsWithoutCt = parameters
            .Where(p => (includeServices || !p.IsService) && (includeTarget || !p.IsTarget) && !p.IsCancellationToken)
            .ToList();

        var hasParamsParameter = paramsWithoutCt.Any(p => p.IsParams);

        if (hasParamsParameter)
        {
            var regularParams = paramsWithoutCt.Where(p => !p.IsParams).Select(p => $"{p.Type} {p.Name}").ToList();
            var paramsParam = paramsWithoutCt.First(p => p.IsParams);

            regularParams.Add("CancellationToken cancellationToken = default");
            regularParams.Add($"params {paramsParam.Type} {paramsParam.Name}");

            return string.Join(", ", regularParams);
        }
        else
        {
            var paramsList = paramsWithoutCt.Select(p => $"{p.Type} {p.Name}").ToList();
            paramsList.Add("CancellationToken cancellationToken = default");
            return string.Join(", ", paramsList);
        }
    }

    private static string GetParameterIdentifiersWithCancellationToken(IReadOnlyList<ParameterModel> parameters, bool includeServices = true, bool includeTarget = true)
    {
        var paramsWithoutCt = parameters
            .Where(p => (includeServices || !p.IsService) && (includeTarget || !p.IsTarget) && !p.IsCancellationToken)
            .ToList();

        var hasParamsParameter = paramsWithoutCt.Any(p => p.IsParams);

        if (hasParamsParameter)
        {
            var regularParams = paramsWithoutCt.Where(p => !p.IsParams).Select(p => p.Name).ToList();
            var paramsParam = paramsWithoutCt.First(p => p.IsParams);

            regularParams.Add("cancellationToken");
            regularParams.Add(paramsParam.Name);

            return string.Join(", ", regularParams);
        }
        else
        {
            var identifiersList = paramsWithoutCt.Select(p => p.Name).ToList();
            identifiersList.Add("cancellationToken");
            return string.Join(", ", identifiersList);
        }
    }

    private static string GetParameterIdentifiersForDomainInvocation(IReadOnlyList<ParameterModel> parameters)
    {
        // Include services, exclude target, pass cancellationToken if present
        return string.Join(", ", parameters
            .Where(p => !p.IsTarget)
            .Select(p => p.IsCancellationToken ? "cancellationToken" : p.Name));
    }

    private static string BuildEventMethodInvocationParams(EventMethodModel evt)
    {
        // Build the full parameter list including services
        var allParams = new List<string>();

        // Add data parameters (exclude CancellationToken - it's handled separately as 'ct')
        allParams.AddRange(evt.Parameters
            .Where(p => !p.IsCancellationToken)
            .Select(p => p.Name));

        // Add service parameters (resolved from DI)
        allParams.AddRange(evt.ServiceParameters.Select(p => p.Name));

        // Add ct if domain method has CancellationToken
        if (evt.Parameters.Any(p => p.IsCancellationToken))
        {
            allParams.Add("ct");
        }

        return string.Join(", ", allParams);
    }

    #endregion
}
