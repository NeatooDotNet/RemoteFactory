using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using CombinationTestGenerator.Models;
using CombinationTestGenerator.Generation;

namespace CombinationTestGenerator;

/// <summary>
/// Source generator that creates test target classes for all valid factory method combinations.
/// </summary>
[Generator]
public class CombinationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Load configuration from embedded resource
        var config = LoadConfiguration();
        if (config == null)
        {
            return;
        }

        // Generate all valid combinations
        var combinations = GenerateCombinations(config);

        // Register source output
        context.RegisterPostInitializationOutput(ctx =>
        {
            // Group combinations by operation for file organization
            var byOperation = combinations.GroupBy(c => c.Operation);

            foreach (var group in byOperation)
            {
                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated />");
                sb.AppendLine("#nullable enable");
                sb.AppendLine();
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Threading;");
                sb.AppendLine("using System.Threading.Tasks;");
                sb.AppendLine("using Neatoo.RemoteFactory;");
                sb.AppendLine("using RemoteFactory.IntegrationTests.Shared;");
                sb.AppendLine();
                sb.AppendLine("namespace RemoteFactory.IntegrationTests.Generated.CombinationTargets;");
                sb.AppendLine();

                foreach (var combination in group)
                {
                    try
                    {
                        var classCode = GenerateClassBody(combination, config);
                        sb.AppendLine(classCode);
                        sb.AppendLine();
                    }
                    catch (Exception ex)
                    {
                        sb.AppendLine($"// Error generating {combination.ClassName}: {ex.Message}");
                    }
                }

                ctx.AddSource($"{group.Key}Combinations.g.cs", sb.ToString());
            }

            // Generate metadata file
            var metadataSb = new StringBuilder();
            GenerateMetadata(metadataSb, combinations);
            ctx.AddSource("CombinationMetadata.g.cs", metadataSb.ToString());
        });
    }

    private ConfigurationRoot? LoadConfiguration()
    {
        var assembly = typeof(CombinationGenerator).Assembly;
        var resourceName = "CombinationTestGenerator.CombinationDimensions.json";

        using var stream = assembly.GetManifestResourceStream(resourceName);
        if (stream == null)
        {
            return null;
        }

        using var reader = new StreamReader(stream);
        var json = reader.ReadToEnd();

        // Parse using simple JSON parser
        return ParseConfiguration(json);
    }

    private ConfigurationRoot ParseConfiguration(string json)
    {
        var parser = new SimpleJsonParser(json);
        var root = parser.Parse() as Dictionary<string, object?>;
        if (root == null)
        {
            return new ConfigurationRoot();
        }

        var config = new ConfigurationRoot();

        // Parse operations
        if (root.TryGetValue("operations", out var operationsObj) && operationsObj is List<object?> operationsArray)
        {
            config.Operations = ParseOperations(operationsArray);
        }

        // Parse return types
        if (root.TryGetValue("returnTypes", out var returnTypesObj) && returnTypesObj is Dictionary<string, object?> returnTypesDict)
        {
            config.ReturnTypes = ParseReturnTypes(returnTypesDict);
        }

        // Parse parameters
        if (root.TryGetValue("parameters", out var parametersObj) && parametersObj is Dictionary<string, object?> parametersDict)
        {
            config.Parameters = ParseParameters(parametersDict);
        }

        // Parse invalid combinations
        if (root.TryGetValue("invalidCombinations", out var invalidObj) && invalidObj is List<object?> invalidArray)
        {
            config.InvalidCombinations = ParseInvalidCombinations(invalidArray);
        }

        return config;
    }

    private List<OperationInfo> ParseOperations(List<object?> operationsArray)
    {
        var result = new List<OperationInfo>();

        foreach (var opObj in operationsArray)
        {
            if (opObj is Dictionary<string, object?> opDict)
            {
                var op = new OperationInfo
                {
                    Name = GetString(opDict, "name"),
                    Attribute = GetString(opDict, "attribute"),
                    ValidReturnTypes = GetStringList(opDict, "validReturnTypes"),
                    ValidParameters = GetStringList(opDict, "validParameters"),
                    ValidExecutionModes = GetStringList(opDict, "validExecutionModes"),
                    SignatureTypes = GetStringList(opDict, "signatureTypes"),
                    Constraints = GetStringList(opDict, "constraints"),
                    GenerateTestTargets = GetBool(opDict, "generateTestTargets", true)
                };
                result.Add(op);
            }
        }

        return result;
    }

    private Dictionary<string, ReturnTypeInfo> ParseReturnTypes(Dictionary<string, object?> returnTypesDict)
    {
        var result = new Dictionary<string, ReturnTypeInfo>();

        foreach (var kvp in returnTypesDict)
        {
            if (kvp.Value is Dictionary<string, object?> typeDict)
            {
                result[kvp.Key] = new ReturnTypeInfo
                {
                    CSharpType = GetString(typeDict, "csharpType"),
                    TaskVariant = GetStringNullable(typeDict, "taskVariant"),
                    IsAsync = GetBool(typeDict, "isAsync", false),
                    IsBool = GetBool(typeDict, "isBool", false),
                    ReturnsTarget = GetBool(typeDict, "returnsTarget", false)
                };
            }
        }

        return result;
    }

    private Dictionary<string, List<ParameterDefinition>> ParseParameters(Dictionary<string, object?> parametersDict)
    {
        var result = new Dictionary<string, List<ParameterDefinition>>();

        foreach (var kvp in parametersDict)
        {
            var paramList = new List<ParameterDefinition>();

            if (kvp.Value is List<object?> paramArray)
            {
                foreach (var paramObj in paramArray)
                {
                    if (paramObj is Dictionary<string, object?> paramDict)
                    {
                        paramList.Add(new ParameterDefinition
                        {
                            Type = GetString(paramDict, "type"),
                            Name = GetString(paramDict, "name"),
                            Attribute = GetStringNullable(paramDict, "attribute"),
                            IsService = GetBool(paramDict, "isService", false)
                        });
                    }
                }
            }

            result[kvp.Key] = paramList;
        }

        return result;
    }

    private List<InvalidCombinationInfo> ParseInvalidCombinations(List<object?> invalidArray)
    {
        var result = new List<InvalidCombinationInfo>();

        foreach (var invalidObj in invalidArray)
        {
            if (invalidObj is Dictionary<string, object?> invalidDict)
            {
                result.Add(new InvalidCombinationInfo
                {
                    Operation = GetStringNullable(invalidDict, "operation"),
                    ReturnType = GetStringNullable(invalidDict, "returnType"),
                    Constraint = GetStringNullable(invalidDict, "constraint"),
                    Diagnostic = GetString(invalidDict, "diagnostic"),
                    Reason = GetString(invalidDict, "reason")
                });
            }
        }

        return result;
    }

    private static string GetString(Dictionary<string, object?> dict, string key)
    {
        if (dict.TryGetValue(key, out var value) && value is string str)
        {
            return str;
        }
        return string.Empty;
    }

    private static string? GetStringNullable(Dictionary<string, object?> dict, string key)
    {
        if (dict.TryGetValue(key, out var value))
        {
            return value as string;
        }
        return null;
    }

    private static bool GetBool(Dictionary<string, object?> dict, string key, bool defaultValue)
    {
        if (dict.TryGetValue(key, out var value) && value is bool b)
        {
            return b;
        }
        return defaultValue;
    }

    private static List<string> GetStringList(Dictionary<string, object?> dict, string key)
    {
        var result = new List<string>();
        if (dict.TryGetValue(key, out var value) && value is List<object?> list)
        {
            foreach (var item in list)
            {
                if (item is string str)
                {
                    result.Add(str);
                }
            }
        }
        return result;
    }

    private List<CombinationInfo> GenerateCombinations(ConfigurationRoot config)
    {
        var combinations = new List<CombinationInfo>();

        foreach (var operation in config.Operations)
        {
            if (!operation.GenerateTestTargets)
                continue;

            foreach (var returnType in operation.ValidReturnTypes)
            {
                // Check if this is an invalid combination
                if (IsInvalidCombination(config, operation.Name, returnType))
                    continue;

                foreach (var parameters in operation.ValidParameters)
                {
                    foreach (var executionMode in operation.ValidExecutionModes)
                    {
                        // For operations with signature types, generate each variation
                        if (operation.SignatureTypes.Count > 0)
                        {
                            foreach (var signatureType in operation.SignatureTypes)
                            {
                                // Constructor signature only makes sense for certain return types
                                if (signatureType == "Constructor" &&
                                    (returnType == "Void" || returnType == "Task" || returnType == "Bool" || returnType == "TaskBool"))
                                {
                                    // Skip constructor for void/task/bool returns - doesn't make sense
                                    continue;
                                }

                                combinations.Add(new CombinationInfo
                                {
                                    Operation = operation.Name,
                                    ReturnType = returnType,
                                    Parameters = parameters,
                                    ExecutionMode = executionMode,
                                    SignatureType = signatureType
                                });
                            }
                        }
                        else
                        {
                            combinations.Add(new CombinationInfo
                            {
                                Operation = operation.Name,
                                ReturnType = returnType,
                                Parameters = parameters,
                                ExecutionMode = executionMode,
                                SignatureType = "Instance"
                            });
                        }
                    }
                }
            }
        }

        return combinations;
    }

    private bool IsInvalidCombination(ConfigurationRoot config, string operation, string returnType)
    {
        foreach (var invalid in config.InvalidCombinations)
        {
            if (invalid.Operation == operation && invalid.ReturnType == returnType)
            {
                return true;
            }
        }
        return false;
    }

    private string GenerateClassBody(CombinationInfo combination, ConfigurationRoot config)
    {
        var returnTypeInfo = config.ReturnTypes[combination.ReturnType];
        var parameters = config.Parameters[combination.Parameters];
        var operation = config.Operations.Find(o => o.Name == combination.Operation);

        if (operation == null)
        {
            return $"// Operation {combination.Operation} not found";
        }

        var sb = new StringBuilder();
        var className = combination.ClassName;
        var isRemote = combination.ExecutionMode == "Remote";

        if (combination.Operation == "Execute")
        {
            GenerateExecuteClassBody(sb, combination, returnTypeInfo, parameters);
        }
        else if (combination.Operation == "Event")
        {
            GenerateEventClassBody(sb, combination, returnTypeInfo, parameters, isRemote);
        }
        else if (IsWriteOperation(combination.Operation))
        {
            GenerateWriteClassBody(sb, combination, operation, returnTypeInfo, parameters, isRemote);
        }
        else
        {
            GenerateReadClassBody(sb, combination, operation, returnTypeInfo, parameters, isRemote);
        }

        return sb.ToString();
    }

    private bool IsWriteOperation(string operation)
    {
        return operation == "Insert" || operation == "Update" || operation == "Delete";
    }

    private void GenerateReadClassBody(
        StringBuilder sb,
        CombinationInfo combination,
        OperationInfo operation,
        ReturnTypeInfo returnType,
        List<ParameterDefinition> parameters,
        bool isRemote)
    {
        var className = combination.ClassName;
        var isConstructor = combination.SignatureType == "Constructor";

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Test target: {combination.Operation}, {combination.ReturnType}, {combination.Parameters}, {combination.ExecutionMode}, {combination.SignatureType}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"[Factory]");
        sb.AppendLine($"public class {className}");
        sb.AppendLine("{");

        // Properties
        sb.AppendLine("    public bool OperationCalled { get; set; }");
        sb.AppendLine("    public int ReceivedIntParam { get; set; }");
        sb.AppendLine("    public string? ReceivedStringParam { get; set; }");
        sb.AppendLine("    public bool ServiceWasInjected { get; set; }");
        sb.AppendLine("    public bool CancellationTokenReceived { get; set; }");
        sb.AppendLine();

        // Default constructor for serialization
        sb.AppendLine($"    public {className}() {{ }}");
        sb.AppendLine();

        if (isConstructor && combination.Operation == "Create")
        {
            // Constructor-based create
            var paramList = BuildParameterList(parameters);
            var remoteAttr = isRemote ? "    [Remote]" : "";
            if (!string.IsNullOrEmpty(remoteAttr))
            {
                sb.AppendLine(remoteAttr);
            }
            sb.AppendLine("    [Create]");
            sb.AppendLine($"    public {className}({paramList})");
            sb.AppendLine("    {");
            sb.AppendLine("        OperationCalled = true;");
            GenerateParameterAssignments(sb, parameters);
            sb.AppendLine("    }");
        }
        else
        {
            // Static method
            var paramList = BuildParameterList(parameters);
            var remoteAttr = isRemote ? "    [Remote]" : "";
            var methodReturnType = GetMethodReturnType(returnType, className);

            if (!string.IsNullOrEmpty(remoteAttr))
            {
                sb.AppendLine(remoteAttr);
            }
            sb.AppendLine($"    [{combination.Operation}]");
            sb.AppendLine($"    public static {methodReturnType} {combination.Operation}Op({paramList})");
            sb.AppendLine("    {");
            sb.AppendLine($"        var result = new {className}();");
            sb.AppendLine("        result.OperationCalled = true;");
            GenerateParameterAssignments(sb, parameters, "result.");

            if (returnType.IsBool && !returnType.IsAsync)
            {
                sb.AppendLine("        return true;");
            }
            else if (returnType.IsBool && returnType.IsAsync)
            {
                sb.AppendLine("        return Task.FromResult(true);");
            }
            else if (returnType.IsAsync && returnType.ReturnsTarget)
            {
                sb.AppendLine($"        return Task.FromResult<{className}?>(result);");
            }
            else if (returnType.IsAsync && !returnType.ReturnsTarget)
            {
                sb.AppendLine("        return Task.CompletedTask;");
            }
            else if (returnType.ReturnsTarget)
            {
                sb.AppendLine("        return result;");
            }

            sb.AppendLine("    }");
        }

        sb.AppendLine("}");
    }

    private void GenerateWriteClassBody(
        StringBuilder sb,
        CombinationInfo combination,
        OperationInfo operation,
        ReturnTypeInfo returnType,
        List<ParameterDefinition> parameters,
        bool isRemote)
    {
        var className = combination.ClassName;

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Test target: {combination.Operation}, {combination.ReturnType}, {combination.Parameters}, {combination.ExecutionMode}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"[Factory]");
        sb.AppendLine($"public class {className} : Neatoo.RemoteFactory.IFactorySaveMeta");
        sb.AppendLine("{");

        // Properties
        sb.AppendLine("    public bool OperationCalled { get; set; }");
        sb.AppendLine("    public string? LastOperationCalled { get; set; }");
        sb.AppendLine("    public int ReceivedIntParam { get; set; }");
        sb.AppendLine("    public string? ReceivedStringParam { get; set; }");
        sb.AppendLine("    public bool ServiceWasInjected { get; set; }");
        sb.AppendLine("    public bool CancellationTokenReceived { get; set; }");
        sb.AppendLine();
        sb.AppendLine("    // IFactorySaveMeta implementation");
        sb.AppendLine("    public bool IsNew { get; set; } = true;");
        sb.AppendLine("    public bool IsDeleted { get; set; }");
        sb.AppendLine();

        // Default constructor
        sb.AppendLine($"    public {className}() {{ }}");
        sb.AppendLine();

        // Create method
        sb.AppendLine("    [Create]");
        sb.AppendLine($"    public static {className} CreateOp()");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {className}();");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Write method
        var paramList = BuildParameterList(parameters);
        var remoteAttr = isRemote ? "    [Remote]" : "";
        var methodReturnType = GetWriteMethodReturnType(returnType);

        if (!string.IsNullOrEmpty(remoteAttr))
        {
            sb.AppendLine(remoteAttr);
        }
        sb.AppendLine($"    [{combination.Operation}]");
        sb.AppendLine($"    public {methodReturnType} {combination.Operation}Op({paramList})");
        sb.AppendLine("    {");
        sb.AppendLine("        OperationCalled = true;");
        sb.AppendLine($"        LastOperationCalled = \"{combination.Operation}\";");
        GenerateParameterAssignments(sb, parameters);

        if (returnType.IsBool && !returnType.IsAsync)
        {
            sb.AppendLine("        return true;");
        }
        else if (returnType.IsBool && returnType.IsAsync)
        {
            sb.AppendLine("        return Task.FromResult(true);");
        }
        else if (returnType.IsAsync)
        {
            sb.AppendLine("        return Task.CompletedTask;");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    private void GenerateExecuteClassBody(
        StringBuilder sb,
        CombinationInfo combination,
        ReturnTypeInfo returnType,
        List<ParameterDefinition> parameters)
    {
        var className = combination.ClassName;
        var resultClassName = $"{className}_Result";

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Test target: Execute, {combination.ReturnType}, {combination.Parameters}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"[Factory]");
        sb.AppendLine($"public static partial class {className}");
        sb.AppendLine("{");

        var paramList = BuildParameterList(parameters);
        var methodReturnType = returnType.ReturnsTarget
            ? $"Task<{resultClassName}>"
            : "Task";

        sb.AppendLine("    [Execute]");
        sb.AppendLine($"    public static {methodReturnType} ExecuteOp({paramList})");
        sb.AppendLine("    {");

        if (returnType.ReturnsTarget)
        {
            sb.AppendLine($"        var result = new {resultClassName}();");
            sb.AppendLine("        result.OperationCalled = true;");
            GenerateParameterAssignments(sb, parameters, "result.");
            sb.AppendLine("        return Task.FromResult(result);");
        }
        else
        {
            sb.AppendLine("        return Task.CompletedTask;");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        // Generate result class if needed
        if (returnType.ReturnsTarget)
        {
            sb.AppendLine();
            sb.AppendLine($"/// <summary>Result type for {className}</summary>");
            sb.AppendLine("[Factory]");
            sb.AppendLine($"public class {resultClassName}");
            sb.AppendLine("{");
            sb.AppendLine("    public bool OperationCalled { get; set; }");
            sb.AppendLine("    public int ReceivedIntParam { get; set; }");
            sb.AppendLine("    public string? ReceivedStringParam { get; set; }");
            sb.AppendLine("    public bool ServiceWasInjected { get; set; }");
            sb.AppendLine("    public bool CancellationTokenReceived { get; set; }");
            sb.AppendLine("}");
        }
    }

    private void GenerateEventClassBody(
        StringBuilder sb,
        CombinationInfo combination,
        ReturnTypeInfo returnType,
        List<ParameterDefinition> parameters,
        bool isRemote)
    {
        var className = combination.ClassName;

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Test target: Event, {combination.ReturnType}, {combination.Parameters}, {combination.ExecutionMode}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"[Factory]");
        sb.AppendLine($"public class {className}");
        sb.AppendLine("{");

        // Static tracking
        sb.AppendLine("    public static bool EventFired { get; set; }");
        sb.AppendLine("    public static int ReceivedIntParam { get; set; }");
        sb.AppendLine("    public static string? ReceivedStringParam { get; set; }");
        sb.AppendLine("    public static bool ServiceWasInjected { get; set; }");
        sb.AppendLine("    public static bool CancellationTokenReceived { get; set; }");
        sb.AppendLine();
        sb.AppendLine("    public static void Reset()");
        sb.AppendLine("    {");
        sb.AppendLine("        EventFired = false;");
        sb.AppendLine("        ReceivedIntParam = 0;");
        sb.AppendLine("        ReceivedStringParam = null;");
        sb.AppendLine("        ServiceWasInjected = false;");
        sb.AppendLine("        CancellationTokenReceived = false;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Ensure CancellationToken at end
        var eventParams = EnsureCancellationToken(parameters);
        var paramList = BuildParameterList(eventParams);
        var remoteAttr = isRemote ? "    [Remote]" : "";
        var methodReturnType = returnType.IsAsync ? "Task" : "void";

        if (!string.IsNullOrEmpty(remoteAttr))
        {
            sb.AppendLine(remoteAttr);
        }
        sb.AppendLine("    [Event]");
        sb.AppendLine($"    public {methodReturnType} OnEvent({paramList})");
        sb.AppendLine("    {");
        sb.AppendLine("        EventFired = true;");
        GenerateParameterAssignmentsStatic(sb, eventParams);

        if (returnType.IsAsync)
        {
            sb.AppendLine("        return Task.CompletedTask;");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    private List<ParameterDefinition> EnsureCancellationToken(List<ParameterDefinition> parameters)
    {
        var result = new List<ParameterDefinition>(parameters);

        foreach (var p in result)
        {
            if (p.Type == "CancellationToken")
                return result;
        }

        result.Add(new ParameterDefinition
        {
            Type = "CancellationToken",
            Name = "ct",
            IsService = false
        });

        return result;
    }

    private string BuildParameterList(List<ParameterDefinition> parameters)
    {
        if (parameters.Count == 0)
            return "";

        var parts = new List<string>();
        foreach (var p in parameters)
        {
            var attr = p.IsService ? "[Service] " : "";
            parts.Add($"{attr}{p.Type} {p.Name}");
        }
        return string.Join(", ", parts);
    }

    private void GenerateParameterAssignments(StringBuilder sb, List<ParameterDefinition> parameters, string prefix = "")
    {
        foreach (var p in parameters)
        {
            if (p.Type == "int")
            {
                sb.AppendLine($"        {prefix}ReceivedIntParam = {p.Name};");
            }
            else if (p.Type == "string")
            {
                sb.AppendLine($"        {prefix}ReceivedStringParam = {p.Name};");
            }
            else if (p.IsService || p.Type == "IService")
            {
                sb.AppendLine($"        {prefix}ServiceWasInjected = {p.Name} != null;");
            }
            else if (p.Type == "CancellationToken")
            {
                sb.AppendLine($"        {prefix}CancellationTokenReceived = true;");
            }
        }
    }

    private void GenerateParameterAssignmentsStatic(StringBuilder sb, List<ParameterDefinition> parameters)
    {
        foreach (var p in parameters)
        {
            if (p.Type == "int")
            {
                sb.AppendLine($"        ReceivedIntParam = {p.Name};");
            }
            else if (p.Type == "string")
            {
                sb.AppendLine($"        ReceivedStringParam = {p.Name};");
            }
            else if (p.IsService || p.Type == "IService")
            {
                sb.AppendLine($"        ServiceWasInjected = {p.Name} != null;");
            }
            else if (p.Type == "CancellationToken")
            {
                sb.AppendLine($"        CancellationTokenReceived = true;");
            }
        }
    }

    private string GetMethodReturnType(ReturnTypeInfo returnType, string targetType)
    {
        if (returnType.ReturnsTarget)
        {
            return returnType.IsAsync ? $"Task<{targetType}?>" : targetType;
        }
        if (returnType.IsBool)
        {
            return returnType.IsAsync ? "Task<bool>" : "bool";
        }
        return returnType.IsAsync ? "Task" : "void";
    }

    private string GetWriteMethodReturnType(ReturnTypeInfo returnType)
    {
        if (returnType.IsBool)
        {
            return returnType.IsAsync ? "Task<bool>" : "bool";
        }
        return returnType.IsAsync ? "Task" : "void";
    }

    private void GenerateMetadata(StringBuilder sb, List<CombinationInfo> combinations)
    {
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine("namespace RemoteFactory.IntegrationTests.Generated.CombinationTargets;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Metadata about all generated combination target types.");
        sb.AppendLine("/// NOTE: This file is for documentation and categorization purposes.");
        sb.AppendLine("/// Tests should NOT iterate over these types using reflection.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class CombinationMetadata");
        sb.AppendLine("{");

        // Count by operation
        sb.AppendLine("    /// <summary>Total number of generated combinations.</summary>");
        sb.AppendLine($"    public const int TotalCount = {combinations.Count};");
        sb.AppendLine();

        // Counts by operation
        var byOperation = combinations.GroupBy(c => c.Operation).ToDictionary(g => g.Key, g => g.Count());
        sb.AppendLine("    /// <summary>Counts by operation.</summary>");
        sb.AppendLine("    public static IReadOnlyDictionary<string, int> CountsByOperation { get; } = new Dictionary<string, int>");
        sb.AppendLine("    {");
        foreach (var kvp in byOperation.OrderBy(k => k.Key))
        {
            sb.AppendLine($"        {{ \"{kvp.Key}\", {kvp.Value} }},");
        }
        sb.AppendLine("    };");
        sb.AppendLine();

        // List all class names (for documentation)
        sb.AppendLine("    /// <summary>All generated class names (for documentation only).</summary>");
        sb.AppendLine("    public static IReadOnlyList<string> AllClassNames { get; } = new string[]");
        sb.AppendLine("    {");
        foreach (var c in combinations.OrderBy(c => c.ClassName))
        {
            sb.AppendLine($"        \"{c.ClassName}\",");
        }
        sb.AppendLine("    };");

        sb.AppendLine("}");
    }
}
