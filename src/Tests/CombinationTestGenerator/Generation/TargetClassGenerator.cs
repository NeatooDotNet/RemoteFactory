using System;
using System.Collections.Generic;
using System.Text;
using CombinationTestGenerator.Models;

namespace CombinationTestGenerator.Generation;

/// <summary>
/// Generates test target classes for each valid combination.
/// </summary>
public static class TargetClassGenerator
{
    /// <summary>
    /// Generates a test target class for a combination.
    /// </summary>
    public static string GenerateClass(
        CombinationInfo combination,
        ConfigurationRoot config)
    {
        var returnTypeInfo = config.ReturnTypes[combination.ReturnType];
        var parameters = config.Parameters[combination.Parameters];
        var operation = config.Operations.Find(o => o.Name == combination.Operation)
            ?? throw new InvalidOperationException($"Operation {combination.Operation} not found");

        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Neatoo.RemoteFactory;");
        sb.AppendLine("using RemoteFactory.IntegrationTests.Shared;");
        sb.AppendLine();
        sb.AppendLine("namespace RemoteFactory.IntegrationTests.Generated.CombinationTargets;");
        sb.AppendLine();

        // Generate class based on operation type
        if (combination.Operation == "Execute")
        {
            GenerateExecuteClass(sb, combination, returnTypeInfo, parameters);
        }
        else if (combination.Operation == "Event")
        {
            GenerateEventClass(sb, combination, returnTypeInfo, parameters);
        }
        else if (IsWriteOperation(combination.Operation))
        {
            GenerateWriteClass(sb, combination, operation, returnTypeInfo, parameters);
        }
        else
        {
            GenerateReadClass(sb, combination, operation, returnTypeInfo, parameters);
        }

        return sb.ToString();
    }

    private static bool IsWriteOperation(string operation)
    {
        return operation == "Insert" || operation == "Update" || operation == "Delete";
    }

    private static void GenerateReadClass(
        StringBuilder sb,
        CombinationInfo combination,
        OperationInfo operation,
        ReturnTypeInfo returnType,
        List<ParameterDefinition> parameters)
    {
        var className = combination.ClassName;
        var isRemote = combination.ExecutionMode == "Remote";
        var isConstructor = combination.SignatureType == "Constructor";

        // Class declaration
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Test target: {combination.Operation}, {combination.ReturnType}, {combination.Parameters}, {combination.ExecutionMode}, {combination.SignatureType}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"[Factory]");
        sb.AppendLine($"public class {className}");
        sb.AppendLine("{");

        // Properties for verification
        sb.AppendLine("    public bool OperationCalled { get; set; }");
        sb.AppendLine("    public int ReceivedIntParam { get; set; }");
        sb.AppendLine("    public string? ReceivedStringParam { get; set; }");
        sb.AppendLine("    public bool ServiceWasInjected { get; set; }");
        sb.AppendLine("    public bool CancellationTokenReceived { get; set; }");
        sb.AppendLine();

        // Constructor for serialization
        sb.AppendLine("    public " + className + "() { }");
        sb.AppendLine();

        // Generate the factory method
        if (isConstructor && combination.Operation == "Create")
        {
            // Constructor-based create - use a parameterized constructor
            GenerateConstructorCreate(sb, className, parameters, isRemote);
        }
        else
        {
            // Static method
            GenerateStaticReadMethod(sb, className, combination, operation, returnType, parameters, isRemote);
        }

        sb.AppendLine("}");
    }

    private static void GenerateConstructorCreate(
        StringBuilder sb,
        string className,
        List<ParameterDefinition> parameters,
        bool isRemote)
    {
        var paramList = BuildParameterList(parameters);
        var remoteAttr = isRemote ? "[Remote]" : "";

        sb.AppendLine($"    {remoteAttr}");
        sb.AppendLine($"    [Create]");
        sb.AppendLine($"    public {className}({paramList})");
        sb.AppendLine("    {");
        sb.AppendLine("        OperationCalled = true;");
        GenerateParameterAssignments(sb, parameters);
        sb.AppendLine("    }");
    }

    private static void GenerateStaticReadMethod(
        StringBuilder sb,
        string className,
        CombinationInfo combination,
        OperationInfo operation,
        ReturnTypeInfo returnType,
        List<ParameterDefinition> parameters,
        bool isRemote)
    {
        var paramList = BuildParameterList(parameters);
        var remoteAttr = isRemote ? "[Remote]" : "";
        var methodReturnType = GetMethodReturnType(returnType, className);

        sb.AppendLine($"    {remoteAttr}");
        sb.AppendLine($"    [{combination.Operation}]");
        sb.AppendLine($"    public static {methodReturnType} {combination.Operation}({paramList})");
        sb.AppendLine("    {");

        // Create instance and set properties
        sb.AppendLine($"        var result = new {className}();");
        sb.AppendLine("        result.OperationCalled = true;");
        GenerateParameterAssignments(sb, parameters, "result.");

        // Return based on return type
        if (returnType.IsBool && !returnType.IsAsync)
        {
            sb.AppendLine("        return true;");
        }
        else if (returnType.IsBool && returnType.IsAsync)
        {
            sb.AppendLine("        return Task.FromResult(true);");
        }
        else if (returnType.IsAsync && returnType.ReturnsTarget)
        {
            sb.AppendLine($"        return Task.FromResult<{className}?>(result);");
        }
        else if (returnType.IsAsync && !returnType.ReturnsTarget)
        {
            sb.AppendLine("        return Task.CompletedTask;");
        }
        else if (returnType.ReturnsTarget)
        {
            sb.AppendLine("        return result;");
        }
        // void - no return needed

        sb.AppendLine("    }");
    }

    private static void GenerateWriteClass(
        StringBuilder sb,
        CombinationInfo combination,
        OperationInfo operation,
        ReturnTypeInfo returnType,
        List<ParameterDefinition> parameters)
    {
        var className = combination.ClassName;
        var isRemote = combination.ExecutionMode == "Remote";

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Test target: {combination.Operation}, {combination.ReturnType}, {combination.Parameters}, {combination.ExecutionMode}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"[Factory]");
        sb.AppendLine($"public class {className}");
        sb.AppendLine("{");

        // Properties for verification
        sb.AppendLine("    public bool OperationCalled { get; set; }");
        sb.AppendLine("    public string? LastOperationCalled { get; set; }");
        sb.AppendLine("    public int ReceivedIntParam { get; set; }");
        sb.AppendLine("    public string? ReceivedStringParam { get; set; }");
        sb.AppendLine("    public bool ServiceWasInjected { get; set; }");
        sb.AppendLine("    public bool CancellationTokenReceived { get; set; }");
        sb.AppendLine();

        // State properties for write routing
        sb.AppendLine("    public bool IsNew { get; set; } = true;");
        sb.AppendLine("    public bool IsDeleted { get; set; }");
        sb.AppendLine();

        // Default constructor
        sb.AppendLine($"    public {className}() {{ }}");
        sb.AppendLine();

        // Create method for factory
        sb.AppendLine("    [Create]");
        sb.AppendLine($"    public static {className} Create()");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {className}();");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Write method
        var paramList = BuildParameterList(parameters);
        var remoteAttr = isRemote ? "[Remote]" : "";
        var methodReturnType = GetWriteMethodReturnType(returnType);

        sb.AppendLine($"    {remoteAttr}");
        sb.AppendLine($"    [{combination.Operation}]");
        sb.AppendLine($"    public {methodReturnType} {combination.Operation}Method({paramList})");
        sb.AppendLine("    {");
        sb.AppendLine("        OperationCalled = true;");
        sb.AppendLine($"        LastOperationCalled = \"{combination.Operation}\";");
        GenerateParameterAssignments(sb, parameters);

        // Return based on return type
        if (returnType.IsBool && !returnType.IsAsync)
        {
            sb.AppendLine("        return true;");
        }
        else if (returnType.IsBool && returnType.IsAsync)
        {
            sb.AppendLine("        return Task.FromResult(true);");
        }
        else if (returnType.IsAsync)
        {
            sb.AppendLine("        return Task.CompletedTask;");
        }
        // void - no return needed

        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    private static void GenerateExecuteClass(
        StringBuilder sb,
        CombinationInfo combination,
        ReturnTypeInfo returnType,
        List<ParameterDefinition> parameters)
    {
        var className = combination.ClassName;

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Test target: Execute, {combination.ReturnType}, {combination.Parameters}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"[Factory]");
        sb.AppendLine($"public static partial class {className}");
        sb.AppendLine("{");

        var paramList = BuildParameterList(parameters);
        var methodReturnType = returnType.ReturnsTarget
            ? "Task<ExecuteResult>"
            : "Task";

        sb.AppendLine("    [Execute]");
        sb.AppendLine($"    public static {methodReturnType} ExecuteMethod({paramList})");
        sb.AppendLine("    {");

        if (returnType.ReturnsTarget)
        {
            sb.AppendLine("        var result = new ExecuteResult();");
            sb.AppendLine("        result.OperationCalled = true;");
            GenerateParameterAssignments(sb, parameters, "result.");
            sb.AppendLine("        return Task.FromResult(result);");
        }
        else
        {
            sb.AppendLine("        return Task.CompletedTask;");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        // Generate result type for Execute if needed
        if (returnType.ReturnsTarget)
        {
            sb.AppendLine();
            sb.AppendLine($"/// <summary>Result type for {className}</summary>");
            sb.AppendLine("[Factory]");
            sb.AppendLine("public class ExecuteResult");
            sb.AppendLine("{");
            sb.AppendLine("    public bool OperationCalled { get; set; }");
            sb.AppendLine("    public int ReceivedIntParam { get; set; }");
            sb.AppendLine("    public string? ReceivedStringParam { get; set; }");
            sb.AppendLine("    public bool ServiceWasInjected { get; set; }");
            sb.AppendLine("    public bool CancellationTokenReceived { get; set; }");
            sb.AppendLine("}");
        }
    }

    private static void GenerateEventClass(
        StringBuilder sb,
        CombinationInfo combination,
        ReturnTypeInfo returnType,
        List<ParameterDefinition> parameters)
    {
        var className = combination.ClassName;
        var isRemote = combination.ExecutionMode == "Remote";

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Test target: Event, {combination.ReturnType}, {combination.Parameters}, {combination.ExecutionMode}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"[Factory]");
        sb.AppendLine($"public class {className}");
        sb.AppendLine("{");

        // Static event tracking for verification
        sb.AppendLine("    public static bool EventFired { get; set; }");
        sb.AppendLine("    public static int ReceivedIntParam { get; set; }");
        sb.AppendLine("    public static string? ReceivedStringParam { get; set; }");
        sb.AppendLine("    public static bool ServiceWasInjected { get; set; }");
        sb.AppendLine("    public static bool CancellationTokenReceived { get; set; }");
        sb.AppendLine();
        sb.AppendLine("    public static void Reset()");
        sb.AppendLine("    {");
        sb.AppendLine("        EventFired = false;");
        sb.AppendLine("        ReceivedIntParam = 0;");
        sb.AppendLine("        ReceivedStringParam = null;");
        sb.AppendLine("        ServiceWasInjected = false;");
        sb.AppendLine("        CancellationTokenReceived = false;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Ensure parameters include CancellationToken at the end
        var eventParams = EnsureCancellationToken(parameters);
        var paramList = BuildParameterList(eventParams);
        var remoteAttr = isRemote ? "[Remote]" : "";
        var methodReturnType = returnType.IsAsync ? "Task" : "void";

        sb.AppendLine($"    {remoteAttr}");
        sb.AppendLine("    [Event]");
        sb.AppendLine($"    public {methodReturnType} OnEvent({paramList})");
        sb.AppendLine("    {");
        sb.AppendLine("        EventFired = true;");
        GenerateParameterAssignmentsStatic(sb, eventParams);

        if (returnType.IsAsync)
        {
            sb.AppendLine("        return Task.CompletedTask;");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    private static List<ParameterDefinition> EnsureCancellationToken(List<ParameterDefinition> parameters)
    {
        var result = new List<ParameterDefinition>(parameters);

        // Check if already has CancellationToken
        foreach (var p in result)
        {
            if (p.Type == "CancellationToken")
                return result;
        }

        // Add CancellationToken at the end
        result.Add(new ParameterDefinition
        {
            Type = "CancellationToken",
            Name = "ct",
            IsService = false
        });

        return result;
    }

    private static string BuildParameterList(List<ParameterDefinition> parameters)
    {
        if (parameters.Count == 0)
            return "";

        var parts = new List<string>();
        foreach (var p in parameters)
        {
            var attr = p.IsService ? "[Service] " : "";
            parts.Add($"{attr}{p.Type} {p.Name}");
        }
        return string.Join(", ", parts);
    }

    private static void GenerateParameterAssignments(StringBuilder sb, List<ParameterDefinition> parameters, string prefix = "")
    {
        foreach (var p in parameters)
        {
            if (p.Type == "int")
            {
                sb.AppendLine($"        {prefix}ReceivedIntParam = {p.Name};");
            }
            else if (p.Type == "string")
            {
                sb.AppendLine($"        {prefix}ReceivedStringParam = {p.Name};");
            }
            else if (p.IsService || p.Type == "IService")
            {
                sb.AppendLine($"        {prefix}ServiceWasInjected = {p.Name} != null;");
            }
            else if (p.Type == "CancellationToken")
            {
                sb.AppendLine($"        {prefix}CancellationTokenReceived = true;");
            }
        }
    }

    private static void GenerateParameterAssignmentsStatic(StringBuilder sb, List<ParameterDefinition> parameters)
    {
        foreach (var p in parameters)
        {
            if (p.Type == "int")
            {
                sb.AppendLine($"        ReceivedIntParam = {p.Name};");
            }
            else if (p.Type == "string")
            {
                sb.AppendLine($"        ReceivedStringParam = {p.Name};");
            }
            else if (p.IsService || p.Type == "IService")
            {
                sb.AppendLine($"        ServiceWasInjected = {p.Name} != null;");
            }
            else if (p.Type == "CancellationToken")
            {
                sb.AppendLine($"        CancellationTokenReceived = true;");
            }
        }
    }

    private static string GetMethodReturnType(ReturnTypeInfo returnType, string targetType)
    {
        if (returnType.ReturnsTarget)
        {
            return returnType.IsAsync ? $"Task<{targetType}?>" : targetType;
        }
        if (returnType.IsBool)
        {
            return returnType.IsAsync ? "Task<bool>" : "bool";
        }
        return returnType.IsAsync ? "Task" : "void";
    }

    private static string GetWriteMethodReturnType(ReturnTypeInfo returnType)
    {
        if (returnType.IsBool)
        {
            return returnType.IsAsync ? "Task<bool>" : "bool";
        }
        return returnType.IsAsync ? "Task" : "void";
    }
}
