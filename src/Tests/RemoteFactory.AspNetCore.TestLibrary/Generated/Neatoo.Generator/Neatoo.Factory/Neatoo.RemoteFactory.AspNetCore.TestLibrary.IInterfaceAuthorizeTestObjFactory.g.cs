#nullable enable
using Neatoo.RemoteFactory;
using Neatoo.RemoteFactory.Internal;
using Microsoft.Extensions.DependencyInjection;

/*
												READONLY - DO NOT EDIT!!!!
												Generated by Neatoo.RemoteFactory
					*/
namespace Neatoo.RemoteFactory.AspNetCore.TestLibrary
{
    public interface IInterfaceAuthorizeTestObjFactory : IInterfaceAuthorizeTestObj
    {
        Task<Authorized> CanHasAspAccess(bool hasAccess);
        Task<Authorized> CanNoAspAccess(bool hasAccess);
    }

    internal class InterfaceAuthorizeTestObjFactory : IInterfaceAuthorizeTestObjFactory
    {
        private readonly IServiceProvider ServiceProvider;
        private readonly IMakeRemoteDelegateRequest? MakeRemoteDelegateRequest;
        // Delegates
        public delegate Task<bool> HasAspAccessDelegate(bool hasAccess);
        public delegate Task<bool> NoAspAccessDelegate(bool hasAccess);
        public delegate Task<Authorized> CanHasAspAccessDelegate(bool hasAccess);
        public delegate Task<Authorized> CanNoAspAccessDelegate(bool hasAccess);
        // Delegate Properties to provide Local or Remote fork in execution
        public HasAspAccessDelegate HasAspAccessProperty { get; }
        public NoAspAccessDelegate NoAspAccessProperty { get; }
        public CanHasAspAccessDelegate CanHasAspAccessProperty { get; }
        public CanNoAspAccessDelegate CanNoAspAccessProperty { get; }

        public InterfaceAuthorizeTestObjFactory(IServiceProvider serviceProvider)
        {
            this.ServiceProvider = serviceProvider;
            HasAspAccessProperty = LocalHasAspAccess;
            NoAspAccessProperty = LocalNoAspAccess;
            CanHasAspAccessProperty = LocalCanHasAspAccess;
            CanNoAspAccessProperty = LocalCanNoAspAccess;
        }

        public InterfaceAuthorizeTestObjFactory(IServiceProvider serviceProvider, IMakeRemoteDelegateRequest remoteMethodDelegate)
        {
            this.ServiceProvider = serviceProvider;
            this.MakeRemoteDelegateRequest = remoteMethodDelegate;
            HasAspAccessProperty = RemoteHasAspAccess;
            NoAspAccessProperty = RemoteNoAspAccess;
            CanHasAspAccessProperty = RemoteCanHasAspAccess;
            CanNoAspAccessProperty = RemoteCanNoAspAccess;
        }

        public virtual Task<bool> HasAspAccess(bool hasAccess)
        {
            return HasAspAccessProperty(hasAccess);
        }

        public virtual async Task<bool> RemoteHasAspAccess(bool hasAccess)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<bool>(typeof(HasAspAccessDelegate), [hasAccess], default))!;
        }

        public async Task<bool> LocalHasAspAccess(bool hasAccess)
        {
            Authorized authorized;
            InterfaceAuthorizeTestObjAuth interfaceauthorizetestobjauth = ServiceProvider.GetRequiredService<InterfaceAuthorizeTestObjAuth>();
            authorized = interfaceauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                throw new NotAuthorizedException(authorized);
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "Test role" }], true);
            var target = ServiceProvider.GetRequiredService<IInterfaceAuthorizeTestObj>();
            return await target.HasAspAccess(hasAccess);
        }

        public virtual Task<bool> NoAspAccess(bool hasAccess)
        {
            return NoAspAccessProperty(hasAccess);
        }

        public virtual async Task<bool> RemoteNoAspAccess(bool hasAccess)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<bool>(typeof(NoAspAccessDelegate), [hasAccess], default))!;
        }

        public async Task<bool> LocalNoAspAccess(bool hasAccess)
        {
            Authorized authorized;
            InterfaceAuthorizeTestObjAuth interfaceauthorizetestobjauth = ServiceProvider.GetRequiredService<InterfaceAuthorizeTestObjAuth>();
            authorized = interfaceauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                throw new NotAuthorizedException(authorized);
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData() { Roles = "Not Authorized" }], true);
            var target = ServiceProvider.GetRequiredService<IInterfaceAuthorizeTestObj>();
            return await target.NoAspAccess(hasAccess);
        }

        public virtual Task<Authorized> CanHasAspAccess(bool hasAccess)
        {
            return CanHasAspAccessProperty(hasAccess);
        }

        public virtual async Task<Authorized> RemoteCanHasAspAccess(bool hasAccess)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanHasAspAccessDelegate), [hasAccess], default))!;
        }

        public async Task<Authorized> LocalCanHasAspAccess(bool hasAccess)
        {
            Authorized authorized;
            InterfaceAuthorizeTestObjAuth interfaceauthorizetestobjauth = ServiceProvider.GetRequiredService<InterfaceAuthorizeTestObjAuth>();
            authorized = interfaceauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return authorized;
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "Test role" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public virtual Task<Authorized> CanNoAspAccess(bool hasAccess)
        {
            return CanNoAspAccessProperty(hasAccess);
        }

        public virtual async Task<Authorized> RemoteCanNoAspAccess(bool hasAccess)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanNoAspAccessDelegate), [hasAccess], default))!;
        }

        public async Task<Authorized> LocalCanNoAspAccess(bool hasAccess)
        {
            Authorized authorized;
            InterfaceAuthorizeTestObjAuth interfaceauthorizetestobjauth = ServiceProvider.GetRequiredService<InterfaceAuthorizeTestObjAuth>();
            authorized = interfaceauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return authorized;
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData() { Roles = "Not Authorized" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public static void FactoryServiceRegistrar(IServiceCollection services, NeatooFactory remoteLocal)
        {
            // On the client the Factory is registered
            // All method calls lead to a remote call
            if (remoteLocal == NeatooFactory.Remote)
            {
                services.AddScoped<IInterfaceAuthorizeTestObj, InterfaceAuthorizeTestObjFactory>();
                services.AddScoped<IInterfaceAuthorizeTestObjFactory, InterfaceAuthorizeTestObjFactory>();
            }

            // On the server the Delegates are registered
            // InterfaceAuthorizeTestObjFactory is not used
            // IInterfaceAuthorizeTestObj must be registered to actual implementation
            if (remoteLocal == NeatooFactory.Server)
            {
                services.AddScoped<IInterfaceAuthorizeTestObjFactory, InterfaceAuthorizeTestObjFactory>();
                services.AddScoped<InterfaceAuthorizeTestObjFactory>();
                services.AddScoped<HasAspAccessDelegate>(cc =>
                {
                    var factory = cc.GetRequiredService<IInterfaceAuthorizeTestObjFactory>();
                    return (bool hasAccess) => factory.HasAspAccess(hasAccess);
                });
                services.AddScoped<NoAspAccessDelegate>(cc =>
                {
                    var factory = cc.GetRequiredService<IInterfaceAuthorizeTestObjFactory>();
                    return (bool hasAccess) => factory.NoAspAccess(hasAccess);
                });
                services.AddScoped<CanHasAspAccessDelegate>(cc =>
                {
                    var factory = cc.GetRequiredService<InterfaceAuthorizeTestObjFactory>();
                    return (bool hasAccess) => factory.LocalCanHasAspAccess(hasAccess);
                });
                services.AddScoped<CanNoAspAccessDelegate>(cc =>
                {
                    var factory = cc.GetRequiredService<InterfaceAuthorizeTestObjFactory>();
                    return (bool hasAccess) => factory.LocalCanNoAspAccess(hasAccess);
                });
            }
        }
    }
}