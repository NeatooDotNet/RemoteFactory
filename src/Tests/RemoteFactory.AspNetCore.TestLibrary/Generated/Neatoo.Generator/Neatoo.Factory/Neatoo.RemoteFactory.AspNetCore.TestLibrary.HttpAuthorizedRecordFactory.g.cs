#nullable enable
using Neatoo.RemoteFactory;
using Neatoo.RemoteFactory.Internal;
using Microsoft.Extensions.DependencyInjection;

/*
							READONLY - DO NOT EDIT!!!!
							Generated by Neatoo.RemoteFactory
*/
namespace Neatoo.RemoteFactory.AspNetCore.TestLibrary
{
    public interface IHttpAuthorizedRecordFactory
    {
        HttpAuthorizedRecord Create(string Name, CancellationToken cancellationToken = default);
        Task<HttpAuthorizedRecord?> FetchAuthorized(string name, CancellationToken cancellationToken = default);
        Task<HttpAuthorizedRecord?> FetchUnauthorized(string name, CancellationToken cancellationToken = default);
        Task<Authorized> CanFetchAuthorized(CancellationToken cancellationToken = default);
        Task<Authorized> CanFetchUnauthorized(CancellationToken cancellationToken = default);
    }

    internal class HttpAuthorizedRecordFactory : FactoryBase<HttpAuthorizedRecord>, IHttpAuthorizedRecordFactory
    {
        private readonly IServiceProvider ServiceProvider;
        private readonly IMakeRemoteDelegateRequest? MakeRemoteDelegateRequest;
        // Delegates
        public delegate Task<Authorized<HttpAuthorizedRecord>> FetchAuthorizedDelegate(string name, CancellationToken cancellationToken = default);
        public delegate Task<Authorized<HttpAuthorizedRecord>> FetchUnauthorizedDelegate(string name, CancellationToken cancellationToken = default);
        public delegate Task<Authorized> CanFetchAuthorizedDelegate(CancellationToken cancellationToken = default);
        public delegate Task<Authorized> CanFetchUnauthorizedDelegate(CancellationToken cancellationToken = default);
        // Delegate Properties to provide Local or Remote fork in execution
        public FetchAuthorizedDelegate FetchAuthorizedProperty { get; }
        public FetchUnauthorizedDelegate FetchUnauthorizedProperty { get; }
        public CanFetchAuthorizedDelegate CanFetchAuthorizedProperty { get; }
        public CanFetchUnauthorizedDelegate CanFetchUnauthorizedProperty { get; }

        public HttpAuthorizedRecordFactory(IServiceProvider serviceProvider, IFactoryCore<HttpAuthorizedRecord> factoryCore) : base(factoryCore)
        {
            this.ServiceProvider = serviceProvider;
            FetchAuthorizedProperty = LocalFetchAuthorized;
            FetchUnauthorizedProperty = LocalFetchUnauthorized;
            CanFetchAuthorizedProperty = LocalCanFetchAuthorized;
            CanFetchUnauthorizedProperty = LocalCanFetchUnauthorized;
        }

        public HttpAuthorizedRecordFactory(IServiceProvider serviceProvider, IMakeRemoteDelegateRequest remoteMethodDelegate, IFactoryCore<HttpAuthorizedRecord> factoryCore) : base(factoryCore)
        {
            this.ServiceProvider = serviceProvider;
            this.MakeRemoteDelegateRequest = remoteMethodDelegate;
            FetchAuthorizedProperty = RemoteFetchAuthorized;
            FetchUnauthorizedProperty = RemoteFetchUnauthorized;
            CanFetchAuthorizedProperty = RemoteCanFetchAuthorized;
            CanFetchUnauthorizedProperty = RemoteCanFetchUnauthorized;
        }

        public virtual HttpAuthorizedRecord Create(string Name, CancellationToken cancellationToken = default)
        {
            return LocalCreate(Name, cancellationToken);
        }

        public HttpAuthorizedRecord LocalCreate(string Name, CancellationToken cancellationToken = default)
        {
            return DoFactoryMethodCall(FactoryOperation.Create, () => new HttpAuthorizedRecord(Name));
        }

        public virtual async Task<HttpAuthorizedRecord?> FetchAuthorized(string name, CancellationToken cancellationToken = default)
        {
            return (await FetchAuthorizedProperty(name, cancellationToken)).Result;
        }

        public virtual async Task<Authorized<HttpAuthorizedRecord>> RemoteFetchAuthorized(string name, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized<HttpAuthorizedRecord>>(typeof(FetchAuthorizedDelegate), [name], cancellationToken))!;
        }

        public async Task<Authorized<HttpAuthorizedRecord>> LocalFetchAuthorized(string name, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "Test role" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized<HttpAuthorizedRecord>(authorized);
            }

            return new Authorized<HttpAuthorizedRecord>(DoFactoryMethodCall(FactoryOperation.Fetch, () => HttpAuthorizedRecord.FetchAuthorized(name)));
        }

        public virtual async Task<HttpAuthorizedRecord?> FetchUnauthorized(string name, CancellationToken cancellationToken = default)
        {
            return (await FetchUnauthorizedProperty(name, cancellationToken)).Result;
        }

        public virtual async Task<Authorized<HttpAuthorizedRecord>> RemoteFetchUnauthorized(string name, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized<HttpAuthorizedRecord>>(typeof(FetchUnauthorizedDelegate), [name], cancellationToken))!;
        }

        public async Task<Authorized<HttpAuthorizedRecord>> LocalFetchUnauthorized(string name, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData() { Roles = "No auth" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized<HttpAuthorizedRecord>(authorized);
            }

            return new Authorized<HttpAuthorizedRecord>(DoFactoryMethodCall(FactoryOperation.Fetch, () => HttpAuthorizedRecord.FetchUnauthorized(name)));
        }

        public virtual Task<Authorized> CanFetchAuthorized(CancellationToken cancellationToken = default)
        {
            return CanFetchAuthorizedProperty(cancellationToken);
        }

        public virtual async Task<Authorized> RemoteCanFetchAuthorized(CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanFetchAuthorizedDelegate), [], cancellationToken))!;
        }

        public async Task<Authorized> LocalCanFetchAuthorized(CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "Test role" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public virtual Task<Authorized> CanFetchUnauthorized(CancellationToken cancellationToken = default)
        {
            return CanFetchUnauthorizedProperty(cancellationToken);
        }

        public virtual async Task<Authorized> RemoteCanFetchUnauthorized(CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanFetchUnauthorizedDelegate), [], cancellationToken))!;
        }

        public async Task<Authorized> LocalCanFetchUnauthorized(CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData() { Roles = "No auth" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public static void FactoryServiceRegistrar(IServiceCollection services, NeatooFactory remoteLocal)
        {
            services.AddScoped<HttpAuthorizedRecordFactory>();
            services.AddScoped<IHttpAuthorizedRecordFactory, HttpAuthorizedRecordFactory>();
            services.AddScoped<FetchAuthorizedDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<HttpAuthorizedRecordFactory>();
                return (string name, CancellationToken cancellationToken = default) => factory.LocalFetchAuthorized(name, cancellationToken);
            });
            services.AddScoped<FetchUnauthorizedDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<HttpAuthorizedRecordFactory>();
                return (string name, CancellationToken cancellationToken = default) => factory.LocalFetchUnauthorized(name, cancellationToken);
            });
            services.AddScoped<CanFetchAuthorizedDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<HttpAuthorizedRecordFactory>();
                return (CancellationToken cancellationToken = default) => factory.LocalCanFetchAuthorized(cancellationToken);
            });
            services.AddScoped<CanFetchUnauthorizedDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<HttpAuthorizedRecordFactory>();
                return (CancellationToken cancellationToken = default) => factory.LocalCanFetchUnauthorized(cancellationToken);
            });
            // Register AOT-compatible ordinal converter
            global::Neatoo.RemoteFactory.Internal.NeatooOrdinalConverterFactory.RegisterConverter(HttpAuthorizedRecord.CreateOrdinalConverter());
            // Event registrations
            if (remoteLocal == NeatooFactory.Remote)
            {
            }

            if (remoteLocal == NeatooFactory.Logical || remoteLocal == NeatooFactory.Server)
            {
            }
        }
    }
}