#nullable enable
using Neatoo.RemoteFactory;
using Neatoo.RemoteFactory.Internal;
using Microsoft.Extensions.DependencyInjection;

/*
    READONLY - DO NOT EDIT!!!!
    Generated by Neatoo.RemoteFactory
*/
namespace Neatoo.RemoteFactory.AspNetCore.TestLibrary
{
    public interface IAspAuthorizeTestObjFactory
    {
        Task<AspAuthorizeTestObj?> Create(bool hasAccess, CancellationToken cancellationToken = default);
        Task<AspAuthorizeTestObj?> CreateNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default);
        Task<AspAuthorizeTestObj?> CreateMultiple(bool hasAccess, CancellationToken cancellationToken = default);
        Task<AspAuthorizeTestObj?> Save(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default);
        Task<Authorized<AspAuthorizeTestObj>> TrySave(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default);
        Task<AspAuthorizeTestObj?> SaveNoAspAuth(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default);
        Task<Authorized<AspAuthorizeTestObj>> TrySaveNoAspAuth(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default);
        Task<Authorized> CanCreate(bool hasAccess, CancellationToken cancellationToken = default);
        Task<Authorized> CanCreateNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default);
        Task<Authorized> CanCreateMultiple(bool hasAccess, CancellationToken cancellationToken = default);
        Task<Authorized> CanInsert(bool hasAccess, CancellationToken cancellationToken = default);
        Task<Authorized> CanInsertNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default);
        Task<Authorized> CanSave(bool hasAccess, CancellationToken cancellationToken = default);
        Task<Authorized> CanSaveNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default);
    }

    internal class AspAuthorizeTestObjFactory : FactoryBase<AspAuthorizeTestObj>, IAspAuthorizeTestObjFactory
    {
        private readonly IServiceProvider ServiceProvider;
        private readonly IMakeRemoteDelegateRequest? MakeRemoteDelegateRequest;
        // Delegates
        public delegate Task<Authorized<AspAuthorizeTestObj>> CreateDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized<AspAuthorizeTestObj>> CreateNoAspAuthDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized<AspAuthorizeTestObj>> CreateMultipleDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized<AspAuthorizeTestObj>> SaveDelegate(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized<AspAuthorizeTestObj>> SaveNoAspAuthDelegate(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized> CanCreateDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized> CanCreateNoAspAuthDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized> CanCreateMultipleDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized> CanInsertDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized> CanInsertNoAspAuthDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized> CanSaveDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        public delegate Task<Authorized> CanSaveNoAspAuthDelegate(bool hasAccess, CancellationToken cancellationToken = default);
        // Delegate Properties to provide Local or Remote fork in execution
        public CreateDelegate CreateProperty { get; }
        public CreateNoAspAuthDelegate CreateNoAspAuthProperty { get; }
        public CreateMultipleDelegate CreateMultipleProperty { get; }
        public SaveDelegate SaveProperty { get; }
        public SaveNoAspAuthDelegate SaveNoAspAuthProperty { get; }
        public CanCreateDelegate CanCreateProperty { get; }
        public CanCreateNoAspAuthDelegate CanCreateNoAspAuthProperty { get; }
        public CanCreateMultipleDelegate CanCreateMultipleProperty { get; }
        public CanInsertDelegate CanInsertProperty { get; }
        public CanInsertNoAspAuthDelegate CanInsertNoAspAuthProperty { get; }
        public CanSaveDelegate CanSaveProperty { get; }
        public CanSaveNoAspAuthDelegate CanSaveNoAspAuthProperty { get; }

        public AspAuthorizeTestObjFactory(IServiceProvider serviceProvider, IFactoryCore<AspAuthorizeTestObj> factoryCore) : base(factoryCore)
        {
            this.ServiceProvider = serviceProvider;
            CreateProperty = LocalCreate;
            CreateNoAspAuthProperty = LocalCreateNoAspAuth;
            CreateMultipleProperty = LocalCreateMultiple;
            SaveProperty = LocalSave;
            SaveNoAspAuthProperty = LocalSaveNoAspAuth;
            CanCreateProperty = LocalCanCreate;
            CanCreateNoAspAuthProperty = LocalCanCreateNoAspAuth;
            CanCreateMultipleProperty = LocalCanCreateMultiple;
            CanInsertProperty = LocalCanInsert;
            CanInsertNoAspAuthProperty = LocalCanInsertNoAspAuth;
            CanSaveProperty = LocalCanSave;
            CanSaveNoAspAuthProperty = LocalCanSaveNoAspAuth;
        }

        public AspAuthorizeTestObjFactory(IServiceProvider serviceProvider, IMakeRemoteDelegateRequest remoteMethodDelegate, IFactoryCore<AspAuthorizeTestObj> factoryCore) : base(factoryCore)
        {
            this.ServiceProvider = serviceProvider;
            this.MakeRemoteDelegateRequest = remoteMethodDelegate;
            CreateProperty = RemoteCreate;
            CreateNoAspAuthProperty = RemoteCreateNoAspAuth;
            CreateMultipleProperty = RemoteCreateMultiple;
            SaveProperty = RemoteSave;
            SaveNoAspAuthProperty = RemoteSaveNoAspAuth;
            CanCreateProperty = RemoteCanCreate;
            CanCreateNoAspAuthProperty = RemoteCanCreateNoAspAuth;
            CanCreateMultipleProperty = RemoteCanCreateMultiple;
            CanInsertProperty = RemoteCanInsert;
            CanInsertNoAspAuthProperty = RemoteCanInsertNoAspAuth;
            CanSaveProperty = RemoteCanSave;
            CanSaveNoAspAuthProperty = RemoteCanSaveNoAspAuth;
        }

        public virtual async Task<AspAuthorizeTestObj?> Create(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await CreateProperty(hasAccess, cancellationToken)).Result;
        }

        public virtual async Task<Authorized<AspAuthorizeTestObj>> RemoteCreate(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized<AspAuthorizeTestObj>>(typeof(CreateDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized<AspAuthorizeTestObj>> LocalCreate(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "Test role" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var target = ServiceProvider.GetRequiredService<AspAuthorizeTestObj>();
            return new Authorized<AspAuthorizeTestObj>(DoFactoryMethodCall(target, FactoryOperation.Create, () => target.Create(hasAccess)));
        }

        public virtual async Task<AspAuthorizeTestObj?> CreateNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await CreateNoAspAuthProperty(hasAccess, cancellationToken)).Result;
        }

        public virtual async Task<Authorized<AspAuthorizeTestObj>> RemoteCreateNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized<AspAuthorizeTestObj>>(typeof(CreateNoAspAuthDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized<AspAuthorizeTestObj>> LocalCreateNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData() { Roles = "No auth" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var target = ServiceProvider.GetRequiredService<AspAuthorizeTestObj>();
            return new Authorized<AspAuthorizeTestObj>(DoFactoryMethodCall(target, FactoryOperation.Create, () => target.CreateNoAspAuth(hasAccess)));
        }

        public virtual async Task<AspAuthorizeTestObj?> CreateMultiple(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await CreateMultipleProperty(hasAccess, cancellationToken)).Result;
        }

        public virtual async Task<Authorized<AspAuthorizeTestObj>> RemoteCreateMultiple(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized<AspAuthorizeTestObj>>(typeof(CreateMultipleDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized<AspAuthorizeTestObj>> LocalCreateMultiple(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy"), new AspAuthorizeData() { Roles = "Test role 2" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var target = ServiceProvider.GetRequiredService<AspAuthorizeTestObj>();
            return new Authorized<AspAuthorizeTestObj>(DoFactoryMethodCall(target, FactoryOperation.Create, () => target.CreateMultiple(hasAccess)));
        }

        public async Task<Authorized<AspAuthorizeTestObj>> LocalInsert(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "Test role" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var cTarget = (AspAuthorizeTestObj)target ?? throw new Exception("AspAuthorizeTestObj must implement AspAuthorizeTestObj");
            return new Authorized<AspAuthorizeTestObj>(DoFactoryMethodCall(cTarget, FactoryOperation.Insert, () => cTarget.Insert(hasAccess)));
        }

        public async Task<Authorized<AspAuthorizeTestObj>> LocalInsertNoAspAuth(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "No Auth" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized<AspAuthorizeTestObj>(authorized);
            }

            var cTarget = (AspAuthorizeTestObj)target ?? throw new Exception("AspAuthorizeTestObj must implement AspAuthorizeTestObj");
            return new Authorized<AspAuthorizeTestObj>(DoFactoryMethodCall(cTarget, FactoryOperation.Insert, () => cTarget.InsertNoAspAuth(hasAccess)));
        }

        public virtual async Task<AspAuthorizeTestObj?> Save(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            var authorized = (await SaveProperty(target, hasAccess, cancellationToken));
            if (!authorized.HasAccess)
            {
                throw new NotAuthorizedException(authorized);
            }

            return authorized.Result;
        }

        public virtual async Task<Authorized<AspAuthorizeTestObj>> TrySave(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            return await SaveProperty(target, hasAccess, cancellationToken);
        }

        public virtual async Task<Authorized<AspAuthorizeTestObj>> RemoteSave(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized<AspAuthorizeTestObj>>(typeof(SaveDelegate), [target, hasAccess], cancellationToken))!;
        }

        public virtual async Task<Authorized<AspAuthorizeTestObj>> LocalSave(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            if (target.IsDeleted)
            {
                throw new NotImplementedException();
            }
            else if (target.IsNew)
            {
                return await LocalInsert(target, hasAccess, cancellationToken);
            }
            else
            {
                throw new NotImplementedException();
            }
        }

        public virtual async Task<AspAuthorizeTestObj?> SaveNoAspAuth(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            var authorized = (await SaveNoAspAuthProperty(target, hasAccess, cancellationToken));
            if (!authorized.HasAccess)
            {
                throw new NotAuthorizedException(authorized);
            }

            return authorized.Result;
        }

        public virtual async Task<Authorized<AspAuthorizeTestObj>> TrySaveNoAspAuth(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            return await SaveNoAspAuthProperty(target, hasAccess, cancellationToken);
        }

        public virtual async Task<Authorized<AspAuthorizeTestObj>> RemoteSaveNoAspAuth(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized<AspAuthorizeTestObj>>(typeof(SaveNoAspAuthDelegate), [target, hasAccess], cancellationToken))!;
        }

        public virtual async Task<Authorized<AspAuthorizeTestObj>> LocalSaveNoAspAuth(AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default)
        {
            if (target.IsDeleted)
            {
                throw new NotImplementedException();
            }
            else if (target.IsNew)
            {
                return await LocalInsertNoAspAuth(target, hasAccess, cancellationToken);
            }
            else
            {
                throw new NotImplementedException();
            }
        }

        public virtual Task<Authorized> CanCreate(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return CanCreateProperty(hasAccess, cancellationToken);
        }

        public virtual async Task<Authorized> RemoteCanCreate(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanCreateDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized> LocalCanCreate(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return authorized;
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "Test role" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public virtual Task<Authorized> CanCreateNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return CanCreateNoAspAuthProperty(hasAccess, cancellationToken);
        }

        public virtual async Task<Authorized> RemoteCanCreateNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanCreateNoAspAuthDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized> LocalCanCreateNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return authorized;
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData() { Roles = "No auth" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public virtual Task<Authorized> CanCreateMultiple(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return CanCreateMultipleProperty(hasAccess, cancellationToken);
        }

        public virtual async Task<Authorized> RemoteCanCreateMultiple(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanCreateMultipleDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized> LocalCanCreateMultiple(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return authorized;
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy"), new AspAuthorizeData() { Roles = "Test role 2" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public virtual Task<Authorized> CanInsert(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return CanInsertProperty(hasAccess, cancellationToken);
        }

        public virtual async Task<Authorized> RemoteCanInsert(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanInsertDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized> LocalCanInsert(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return authorized;
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "Test role" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public virtual Task<Authorized> CanInsertNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return CanInsertNoAspAuthProperty(hasAccess, cancellationToken);
        }

        public virtual async Task<Authorized> RemoteCanInsertNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanInsertNoAspAuthDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized> LocalCanInsertNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return authorized;
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "No Auth" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public virtual Task<Authorized> CanSave(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return CanSaveProperty(hasAccess, cancellationToken);
        }

        public virtual async Task<Authorized> RemoteCanSave(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanSaveDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized> LocalCanSave(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return authorized;
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "Test role" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public virtual Task<Authorized> CanSaveNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return CanSaveNoAspAuthProperty(hasAccess, cancellationToken);
        }

        public virtual async Task<Authorized> RemoteCanSaveNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            return (await MakeRemoteDelegateRequest!.ForDelegate<Authorized>(typeof(CanSaveNoAspAuthDelegate), [hasAccess], cancellationToken))!;
        }

        public async Task<Authorized> LocalCanSaveNoAspAuth(bool hasAccess, CancellationToken cancellationToken = default)
        {
            Authorized authorized;
            AspAuthorizeTestObjAuth aspauthorizetestobjauth = ServiceProvider.GetRequiredService<AspAuthorizeTestObjAuth>();
            authorized = aspauthorizetestobjauth.HasAccess(hasAccess);
            if (!authorized.HasAccess)
            {
                return authorized;
            }

            var aspAuthorized = ServiceProvider.GetRequiredService<IAspAuthorize>();
            authorized = await aspAuthorized.Authorize([new AspAuthorizeData("TestPolicy") { Roles = "No Auth" }], false);
            if (!authorized.HasAccess)
            {
                return new Authorized(authorized);
            }

            return new Authorized(true);
        }

        public static void FactoryServiceRegistrar(IServiceCollection services, NeatooFactory remoteLocal)
        {
            services.AddScoped<AspAuthorizeTestObjFactory>();
            services.AddScoped<IAspAuthorizeTestObjFactory, AspAuthorizeTestObjFactory>();
            services.AddTransient<AspAuthorizeTestObj>();
            services.AddScoped<CreateDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCreate(hasAccess, cancellationToken);
            });
            services.AddScoped<CreateNoAspAuthDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCreateNoAspAuth(hasAccess, cancellationToken);
            });
            services.AddScoped<CreateMultipleDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCreateMultiple(hasAccess, cancellationToken);
            });
            services.AddScoped<SaveDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalSave(target, hasAccess, cancellationToken);
            });
            services.AddScoped<SaveNoAspAuthDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (AspAuthorizeTestObj target, bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalSaveNoAspAuth(target, hasAccess, cancellationToken);
            });
            services.AddScoped<CanCreateDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCanCreate(hasAccess, cancellationToken);
            });
            services.AddScoped<CanCreateNoAspAuthDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCanCreateNoAspAuth(hasAccess, cancellationToken);
            });
            services.AddScoped<CanCreateMultipleDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCanCreateMultiple(hasAccess, cancellationToken);
            });
            services.AddScoped<CanInsertDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCanInsert(hasAccess, cancellationToken);
            });
            services.AddScoped<CanInsertNoAspAuthDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCanInsertNoAspAuth(hasAccess, cancellationToken);
            });
            services.AddScoped<CanSaveDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCanSave(hasAccess, cancellationToken);
            });
            services.AddScoped<CanSaveNoAspAuthDelegate>(cc =>
            {
                var factory = cc.GetRequiredService<AspAuthorizeTestObjFactory>();
                return (bool hasAccess, CancellationToken cancellationToken = default) => factory.LocalCanSaveNoAspAuth(hasAccess, cancellationToken);
            });
            // Event registrations
            if (remoteLocal == NeatooFactory.Remote)
            {
            }

            if (remoteLocal == NeatooFactory.Logical || remoteLocal == NeatooFactory.Server)
            {
            }
        }
    }
}